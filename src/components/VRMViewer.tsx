'use client';

import { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
import { AvatarData } from '../utils/avatarConfig';
import { VRMAnalyzer } from '../utils/vrmAnalyzer';
import { useMemoryLeakPrevention } from '../utils/memoryLeakPrevention';
import { DynamicMeshDeformer } from '../utils/dynamicMeshDeformation';
import BlendShapeController from './BlendShapeController';
import PerformanceMonitor from './PerformanceMonitor';
import PerformanceMiniWidget from './PerformanceMiniWidget';

interface VRMViewerProps {
  currentBMI: number;
  futureBMI: Array<{ period: number; weight: number; bmi: number }>;
  avatarData: AvatarData;
  userData: {
    height: number;
    weight: number;
    age: number;
    gender: 'male' | 'female';
    excessCalories: string;
  };
  onBMIChange?: (bmi: number) => void;
  isAnimating?: boolean;
}

export default function VRMViewer({ currentBMI, futureBMI, avatarData, userData, onBMIChange, isAnimating }: VRMViewerProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const modalContainerRef = useRef<HTMLDivElement>(null);
  const initRef = useRef(false);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const vrmRef = useRef<unknown>(null);
  const testCubeRef = useRef<THREE.Mesh | null>(null);
  const isCleanedUpRef = useRef(false);
  const meshDeformerRef = useRef<DynamicMeshDeformer | null>(null);
  
  // „É°„É¢„É™„É™„Éº„ÇØÈò≤Ê≠¢„Éï„ÉÉ„ÇØ
  const memoryPrevention = useMemoryLeakPrevention();
  
  // Áä∂ÊÖãÁÆ°ÁêÜ
  const [currentPredictionIndex, setCurrentPredictionIndex] = useState(0);
  const [manualBellyValue, setManualBellyValue] = useState(0);
  const [useManualAdjustment, setUseManualAdjustment] = useState(false);
  const [showDebugInfo, setShowDebugInfo] = useState(false);
  const [availableBlendShapes, setAvailableBlendShapes] = useState<string[]>([]);
  const [currentBlendShape, setCurrentBlendShape] = useState<string>('');
  const [detailedAnalysis, setDetailedAnalysis] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [loadingError, setLoadingError] = useState<string>('');
  const [showPerformanceMonitor, setShowPerformanceMonitor] = useState(false);

  // VRM„ÇíË™≠„ÅøËæº„ÇÄÈñ¢Êï∞Ôºà„Ç∑„É≥„Éó„É´ÁâàÔºâ
  const loadVRM = async (vrmPath: string) => {
    // Âü∫Êú¨„ÉÅ„Çß„ÉÉ„ÇØ
    if (!sceneRef.current || !cameraRef.current || isCleanedUpRef.current || !initRef.current) {
      console.log('‚ùå VRMË™≠„ÅøËæº„Åø‰∏≠Ê≠¢: Êù°‰ª∂‰∏çÊ∫ÄË∂≥');
      return;
    }

    setIsLoading(true);
    setLoadingError('');
    console.log('üì¶ VRMË™≠„ÅøËæº„ÅøÈñãÂßã:', vrmPath);
    console.log('üì¶ „Ç¢„Éê„Çø„Éº„Éá„Éº„Çø:', avatarData);

    try {
      const loader = new GLTFLoader();
      loader.register((parser) => new VRMLoaderPlugin(parser));

      const gltf = await loader.loadAsync(vrmPath);
      
      // Ë™≠„ÅøËæº„ÅøÂæå„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„ÉÅ„Çß„ÉÉ„ÇØ
      if (isCleanedUpRef.current || !initRef.current) {
        console.log('‚ùå VRMË™≠„ÅøËæº„Åø‰∏≠Êñ≠: „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÁä∂ÊÖãÂ§âÊõ¥');
        setIsLoading(false);
        return;
      }

      console.log('‚úÖ VRMË™≠„ÅøËæº„ÅøÊàêÂäü:', gltf);
      const vrm = gltf.userData.vrm;
      console.log('‚úÖ VRM„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà:', vrm);
      console.log('‚úÖ VRM„Å´ÊúüÂæÖ„Åï„Çå„Çãfatness„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó:', avatarData.blendShapeNames.fatness);
      
      let sceneToAdd = null;
      if (vrm && sceneRef.current) {
        sceneToAdd = vrm.scene;
      } else if (gltf.scene && sceneRef.current) {
        sceneToAdd = gltf.scene;
      } else {
        throw new Error('VRM„ÇÇGLTF„Ç∑„Éº„É≥„ÇÇÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì');
      }
      
      if (sceneToAdd && sceneRef.current) {
        // Êó¢Â≠ò„ÅÆVRM„ÇíÂÆåÂÖ®„Å´ÂâäÈô§Ôºà„É°„É¢„É™„É™„Éº„ÇØÂØæÁ≠ñÔºâ
        if (vrmRef.current && sceneRef.current) {
          console.log('üßπ Êó¢Â≠òVRM„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÈñãÂßã');
          
          // VRM„ÅÆÂÆåÂÖ®„Å™dispose
          if (vrmRef.current.scene) {
            vrmRef.current.scene.traverse((object: any) => {
              if (object.geometry) {
                object.geometry.dispose();
              }
              if (object.material) {
                if (Array.isArray(object.material)) {
                  object.material.forEach((material: any) => {
                    if (material.map) material.map.dispose();
                    if (material.normalMap) material.normalMap.dispose();
                    if (material.emissiveMap) material.emissiveMap.dispose();
                    material.dispose();
                  });
                } else {
                  if (object.material.map) object.material.map.dispose();
                  if (object.material.normalMap) object.material.normalMap.dispose();
                  if (object.material.emissiveMap) object.material.emissiveMap.dispose();
                  object.material.dispose();
                }
              }
            });
            sceneRef.current.remove(vrmRef.current.scene);
          }
          
          // VRM expressionManager„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
          if (vrmRef.current.expressionManager) {
            vrmRef.current.expressionManager.destroy();
          }
          
          vrmRef.current = null;
          console.log('‚úÖ VRM„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÂÆå‰∫Ü');
        }
        
        // „ÉÜ„Çπ„Éà„Ç≠„É•„Éº„Éñ„ÇíÂâäÈô§
        if (testCubeRef.current && sceneRef.current) {
          sceneRef.current.remove(testCubeRef.current);
          testCubeRef.current = null;
        }
        
        vrmRef.current = vrm;
        sceneRef.current.add(sceneToAdd);
        
        // VRM„ÅÆÂ†¥Âêà„ÅÆ„ÅøVRMUtils„ÇíÈÅ©Áî®
        if (vrm) {
          VRMUtils.rotateVRM0(vrm);
        }
        
        
        // ÂãïÁöÑ„É°„ÉÉ„Ç∑„É•Â§âÂΩ¢„ÅÆÂàùÊúüÂåñ
        if (!meshDeformerRef.current) {
          meshDeformerRef.current = new DynamicMeshDeformer();
        }
        
        // ‰Ωì„É°„ÉÉ„Ç∑„É•„ÅÆÂÖÉ„Éá„Éº„Çø„Çí‰øùÂ≠ò
        let bodyMeshCount = 0;
        sceneToAdd.traverse((object: any) => {
          if (object.isSkinnedMesh && object.name) {
            const objName = object.name.toLowerCase();
            const isBodyMesh = objName.includes('body') || 
                              objName.includes('merged') ||
                              (!objName.includes('face') && !objName.includes('head') && !objName.includes('hair'));
            
            if (isBodyMesh) {
              meshDeformerRef.current!.saveOriginalVertices(object);
              bodyMeshCount++;
            }
          }
        });
        console.log(`üéØ ‰Ωì„É°„ÉÉ„Ç∑„É•‰øùÂ≠òÂÆå‰∫Ü: ${bodyMeshCount}ÂÄã`);
        
        // „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÂàÜÊûê„ÇíÂÆüË°å
        await analyzeBlendShapes(sceneToAdd, vrm);
        
        // „Ç´„É°„É©‰ΩçÁΩÆË™øÊï¥
        adjustCameraPosition(sceneToAdd);
        
        // ÂàùÊúüBMIÂÄ§„Åß‰ΩìÂûãÊõ¥Êñ∞ÔºàÂãïÁöÑÂ§âÂΩ¢ÁÑ°ÂäπÂåñ„ÅÆ„Åü„ÇÅ‰∏ÄÊôÇÁöÑ„Å´ÁÑ°ÂäπÔºâ
        // if (currentBMI > 0 && !isCleanedUpRef.current) {
        //   setTimeout(() => {
        //     if (!isCleanedUpRef.current) {
        //       updateBodyShape(currentBMI);
        //     }
        //   }, 100);
        // }
      }
    } catch (error) {
      console.error('‚ùå VRMË™≠„ÅøËæº„ÅøÂ§±Êïó:', error);
      if (!isCleanedUpRef.current) {
        setLoadingError(`VRMË™≠„ÅøËæº„Åø„Ç®„É©„Éº: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    } finally {
      if (!isCleanedUpRef.current) {
        setIsLoading(false);
      }
    }
  };

  // „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÂàÜÊûêÈñ¢Êï∞
  const analyzeBlendShapes = async (sceneToAdd: THREE.Object3D, vrm: any) => {
    const allBlendShapes = new Map<string, number>();
    let totalBlendShapes = 0;
    let bodyBlendShapes = 0;
    
    sceneToAdd.traverse((object: any) => {
      if (object.isSkinnedMesh && object.morphTargetDictionary) {
        const blendShapeNames = Object.keys(object.morphTargetDictionary);
        totalBlendShapes += blendShapeNames.length;
        
        blendShapeNames.forEach(name => {
          const index = object.morphTargetDictionary[name];
          const currentValue = object.morphTargetInfluences ? object.morphTargetInfluences[index] : 0;
          allBlendShapes.set(name, currentValue);
          
          const lowerName = name.toLowerCase();
          const isBodyRelated = lowerName.includes('belly') || lowerName.includes('fat') || 
                              lowerName.includes('weight') || lowerName.includes('body') ||
                              lowerName.includes('chest') || lowerName.includes('waist') ||
                              lowerName.includes('hip') || lowerName.includes('muscle') ||
                              lowerName.includes('fatness');
          
          if (isBodyRelated) {
            bodyBlendShapes++;
          }
        });
      }
    });
    
    console.log(`üìä „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó: ÂÖ®${totalBlendShapes}ÂÄã (‰ΩìÂûãÈñ¢ÈÄ£: ${bodyBlendShapes}ÂÄã)`);
    
    // VRMAnalyzer„Çí‰ΩøÁî®„Åó„ÅüË©≥Á¥∞ÂàÜÊûê
    try {
      const analysisResult = VRMAnalyzer.analyzeVRMBlendShapes(vrm);
      console.log('üìà VRMAnalyzerÂàÜÊûêÁµêÊûú:', analysisResult);
      
      // UI„Å´Ë°®Á§∫„Åô„Çã„Åü„ÇÅ„ÅÆÊÉÖÂ†±„Çí‰øùÂ≠ò
      setAvailableBlendShapes(Array.from(allBlendShapes.keys()));
      
      // Á∞°Áï•Âåñ„Åï„Çå„ÅüË©≥Á¥∞ÂàÜÊûêÁµêÊûú„Çí‰ΩúÊàê
      const bodyBlendShapes = Array.from(allBlendShapes.keys()).filter(name => {
        const lowerName = name.toLowerCase();
        return lowerName.includes('belly') || lowerName.includes('weight') || 
               lowerName.includes('fat') || lowerName.includes('body') ||
               lowerName.includes('chest') || lowerName.includes('waist') ||
               lowerName.includes('hip') || lowerName.includes('muscle') ||
               lowerName.includes('fatness');
      });
      
      const detailedAnalysisResult = {
        totalBlendShapes: allBlendShapes.size,
        bodyBlendShapes: bodyBlendShapes.map(name => ({ name, meshName: 'mesh' })),
        faceBlendShapes: [],
        emotionBlendShapes: [],
        unknownBlendShapes: [],
        meshes: [{ name: 'VRM Mesh', blendShapeCount: allBlendShapes.size }],
        totalMemoryUsage: allBlendShapes.size * 1024
      };
      
      setDetailedAnalysis(detailedAnalysisResult);
      
      // ‰ΩøÁî®„Åô„Çã„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÇíÊ±∫ÂÆö
      let usedBlendShape = '';
      const configuredShapes = [
        avatarData.blendShapeNames.belly,
        avatarData.blendShapeNames.weight,
        avatarData.blendShapeNames.fat,
        avatarData.blendShapeNames.fatness
      ].filter(Boolean);
      
      for (const shapeName of configuredShapes) {
        if (allBlendShapes.has(shapeName!)) {
          usedBlendShape = shapeName!;
          break;
        }
      }
      
      // Ë®≠ÂÆö„Åï„Çå„Åü„ÇÇ„ÅÆ„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅÆËá™ÂãïÊ§úÂá∫
      if (!usedBlendShape && bodyBlendShapes.length > 0) {
        usedBlendShape = bodyBlendShapes[0];
        console.log('üîÑ Ëá™ÂãïÊ§úÂá∫„Åï„Çå„Åü„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó:', usedBlendShape);
      }
      
      setCurrentBlendShape(usedBlendShape);
      console.log('üéØ ÊúÄÁµÇÁöÑ„Å´‰ΩøÁî®„Åô„Çã„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó:', usedBlendShape || '„Å™„Åó');
      
    } catch (error) {
      console.error('‚ùå VRMAnalyzerÂàÜÊûê„Ç®„É©„Éº:', error);
    }
  };

  // „Ç´„É°„É©‰ΩçÁΩÆË™øÊï¥
  const adjustCameraPosition = (sceneToAdd: THREE.Object3D) => {
    const box = new THREE.Box3().setFromObject(sceneToAdd);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    
    console.log('üìê VRM„Éê„Ç¶„É≥„Éá„Ç£„É≥„Ç∞„Éú„ÉÉ„ÇØ„Çπ - center:', center, 'size:', size, 'maxDim:', maxDim);
    
    let cameraX, cameraY, cameraZ;
    if (maxDim < 0.5) {
      cameraX = 0;
      cameraY = center.y;
      cameraZ = 1.5;
    } else if (maxDim < 2.0) {
      cameraX = center.x;
      cameraY = center.y;
      cameraZ = maxDim * 1.5;
    } else {
      const fov = cameraRef.current!.fov * (Math.PI / 180);
      cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * 1.2;
      cameraX = center.x;
      cameraY = center.y + size.y / 4;
    }
    
    cameraRef.current!.position.set(cameraX, cameraY, cameraZ);
    cameraRef.current!.lookAt(center);
    
    // „Éï„É©„Çπ„Çø„É†„Ç´„É™„É≥„Ç∞„ÇíÁÑ°ÂäπÂåñ
    sceneToAdd.traverse((child: any) => {
      if (child.isMesh) {
        child.frustumCulled = false;
      }
    });
  };

  // BMI„Å´Âü∫„Å•„ÅÑ„Å¶‰ΩìÂûã„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞ÔºàBlendShapeControllerÂ∞ÇÁî®„É¢„Éº„Éâ„ÅÆ„Åü„ÇÅÁÑ°ÂäπÂåñÔºâ
  const updateBodyShape = (bmiValue: number) => {
    console.log('‚ö†Ô∏è BMIËá™ÂãïÂà∂Âæ°„ÅØ‰∏ÄÊôÇÁöÑ„Å´ÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„ÅôÔºàBlendShapeControllerÂ∞ÇÁî®„É¢„Éº„ÉâÔºâ- BMI:', bmiValue);
    return;
    
    if (!vrmRef.current || isCleanedUpRef.current) return;
    
    console.log('üîç updateBodyShapeÂÆüË°åÈñãÂßã - BMI:', bmiValue, 'ÔºàÂãïÁöÑ„É°„ÉÉ„Ç∑„É•Â§âÂΩ¢„ÅØÁÑ°ÂäπÂåñÔºâ');
    
    // ÂãïÁöÑ„É°„ÉÉ„Ç∑„É•Â§âÂΩ¢„ÇíÁÑ°ÂäπÂåñ„Åó„Å¶„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÅÆ„Åø„Å´ÈõÜ‰∏≠
    // if (meshDeformerRef.current) {
    //   applyDynamicMeshDeformation(bmiValue);
    //   return;
    // }
    
    vrmRef.current.scene.traverse((object: any) => {
      if (object.isSkinnedMesh && object.morphTargetDictionary) {
        const blendShapeNames = avatarData.blendShapeNames;
        let bellyIndex = undefined;
        let usedBlendShapeName = '';

        // Ë®≠ÂÆö„Åï„Çå„Åü„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÇíÊé¢„Åô
        if (blendShapeNames.belly && object.morphTargetDictionary[blendShapeNames.belly] !== undefined) {
          bellyIndex = object.morphTargetDictionary[blendShapeNames.belly];
          usedBlendShapeName = blendShapeNames.belly;
        } else if (blendShapeNames.weight && object.morphTargetDictionary[blendShapeNames.weight] !== undefined) {
          bellyIndex = object.morphTargetDictionary[blendShapeNames.weight];
          usedBlendShapeName = blendShapeNames.weight;
        } else if (blendShapeNames.fat && object.morphTargetDictionary[blendShapeNames.fat] !== undefined) {
          bellyIndex = object.morphTargetDictionary[blendShapeNames.fat];
          usedBlendShapeName = blendShapeNames.fat;
        } else {
          // Ëá™ÂãïÊ§úÂá∫
          const availableBlendShapes = Object.keys(object.morphTargetDictionary);
          const potentialBodyBlendShapes = availableBlendShapes.filter(name => {
            const lowerName = name.toLowerCase();
            return lowerName.includes('belly') || lowerName.includes('fat') || 
                   lowerName.includes('weight') || lowerName.includes('body') ||
                   lowerName.includes('chest') || lowerName.includes('waist') ||
                   lowerName.includes('hip') || lowerName.includes('muscle') ||
                   lowerName.includes('fatness');
          });
          
          if (potentialBodyBlendShapes.length > 0) {
            bellyIndex = object.morphTargetDictionary[potentialBodyBlendShapes[0]];
            usedBlendShapeName = potentialBodyBlendShapes[0];
          }
        }
        
        if (bellyIndex !== undefined) {
          let blendValue = 0;
          
          // ÊâãÂãïË™øÊï¥ÂÄ§„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂ∏∏„Å´ÂÑ™ÂÖà
          if (manualBellyValue > 0) {
            blendValue = manualBellyValue;
            console.log('üéõÔ∏è ÊâãÂãïË™øÊï¥ÂÄ§„Çí‰ΩøÁî®:', blendValue);
          } else if (useManualAdjustment) {
            blendValue = manualBellyValue;
            console.log('üîß ÊâãÂãïË™øÊï¥„É¢„Éº„Éâ:', blendValue);
          } else {
            // BMIËá™ÂãïË®àÁÆó
            if (bmiValue <= 25) {
              blendValue = 0;
            } else if (bmiValue > 25 && bmiValue <= 30) {
              blendValue = ((bmiValue - 25) / 5) * 0.5;
            } else if (bmiValue > 30) {
              blendValue = Math.min(0.5 + ((bmiValue - 30) / 10) * 0.5, 1.0);
            }
            console.log('üßÆ BMIËá™ÂãïË®àÁÆó:', bmiValue, '->', blendValue);
          }
          
          const previousValue = object.morphTargetInfluences[bellyIndex];
          object.morphTargetInfluences[bellyIndex] = blendValue;
          
          console.log('üìà „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÂÄ§„ÇíÊõ¥Êñ∞:', usedBlendShapeName, 'Ââç„ÅÆÂÄ§:', previousValue, 'Êñ∞„Åó„ÅÑÂÄ§:', blendValue);
          setCurrentBlendShape(usedBlendShapeName);
        }
      }
    });
  };

  // ÊâãÂãï„Åß„ÅäËÖπÂë®„Çä„ÇíË™øÊï¥„Åô„ÇãÈñ¢Êï∞
  const handleManualBellyChange = (value: number) => {
    setManualBellyValue(value);
    
    if (vrmRef.current) {
      forceUpdateBlendShape(value);
    }
  };
  
  // Âº∑Âà∂ÁöÑ„Å´„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞Ôºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ
  const forceUpdateBlendShape = (value: number) => {
    if (!vrmRef.current) return;
    
    let updated = false;
    
    vrmRef.current.scene.traverse((object: any) => {
      if (object.isSkinnedMesh && object.morphTargetDictionary) {
        const dictionary = object.morphTargetDictionary;
        const influences = object.morphTargetInfluences;
        
        // Ë®≠ÂÆö„Åï„Çå„Åü„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÇíË©¶Ë°å
        const configuredShapes = [
          avatarData.blendShapeNames.belly,
          avatarData.blendShapeNames.weight,
          avatarData.blendShapeNames.fat,
          avatarData.blendShapeNames.fatness
        ].filter(Boolean);
        
        for (const shapeName of configuredShapes) {
          if (dictionary[shapeName!] !== undefined) {
            const index = dictionary[shapeName!];
            influences[index] = value;
            updated = true;
            setCurrentBlendShape(shapeName!);
            return;
          }
        }
        
        // ‰ΩìÂûãÈñ¢ÈÄ£„ÇíËá™ÂãïÊ§úÂá∫
        if (!updated) {
          const bodyShapes = Object.keys(dictionary).filter(name => {
            const lowerName = name.toLowerCase();
            return lowerName.includes('belly') || lowerName.includes('weight') || 
                   lowerName.includes('fat') || lowerName.includes('body') ||
                   lowerName.includes('chest') || lowerName.includes('waist') ||
                   lowerName.includes('hip') || lowerName.includes('muscle') ||
                   lowerName.includes('fatness');
          });
          
          if (bodyShapes.length > 0) {
            const shapeName = bodyShapes[0];
            const index = dictionary[shapeName];
            influences[index] = value;
            updated = true;
            setCurrentBlendShape(shapeName);
          }
        }
      }
    });
    
    if (!updated) {
      // ÂãïÁöÑ„É°„ÉÉ„Ç∑„É•Â§âÂΩ¢„ÇíÂÆüË°å
      const bmiValue = 18.5 + (value * 16.5);
      console.log(`üîß ÂãïÁöÑÂ§âÂΩ¢ÂÆüË°å: „Çπ„É©„Ç§„ÉÄ„Éº${(value*100).toFixed(0)}% -> BMI${bmiValue.toFixed(1)}`);
      
      if (!meshDeformerRef.current) {
        meshDeformerRef.current = new DynamicMeshDeformer();
      }
      applyDynamicMeshDeformation(bmiValue);
    }
  };

  // ÂãïÁöÑ„É°„ÉÉ„Ç∑„É•Â§âÂΩ¢„Å´„Çà„Çã‰ΩìÂûãÂ§âÊõ¥ÔºàÊñ∞Ê©üËÉΩÔºâ
  const applyDynamicMeshDeformation = (bmiValue: number) => {
    if (!vrmRef.current || !meshDeformerRef.current) return;
    
    const deformationOptions = meshDeformerRef.current.calculateDeformationFromBMI(bmiValue);
    let deformedMeshCount = 0;
    
    vrmRef.current.scene.traverse((object: any) => {
      if (object.isSkinnedMesh && object.name) {
        const objName = object.name.toLowerCase();
        const isBodyMesh = !objName.includes('face') && !objName.includes('head') && !objName.includes('hair');
        
        if (isBodyMesh) {
          meshDeformerRef.current!.deformMesh(object, deformationOptions);
          deformedMeshCount++;
        }
      }
    });
    
    if (deformedMeshCount > 0) {
      setCurrentBlendShape(`ÂãïÁöÑÂ§âÂΩ¢ BMI:${bmiValue.toFixed(1)}`);
      console.log(`‚úÖ ÂãïÁöÑÂ§âÂΩ¢ÂÆå‰∫Ü: ${deformedMeshCount}ÂÄã„ÅÆ„É°„ÉÉ„Ç∑„É•`);
    } else {
      // Âº∑Âà∂ÁöÑ„Å´ÂÖ®SkinnedMesh„Å´ÈÅ©Áî®
      vrmRef.current.scene.traverse((object: any) => {
        if (object.isSkinnedMesh && object.geometry?.attributes?.position) {
          try {
            meshDeformerRef.current!.saveOriginalVertices(object);
            meshDeformerRef.current!.deformMesh(object, deformationOptions);
            deformedMeshCount++;
          } catch (error) {
            console.error(`Â§âÂΩ¢„Ç®„É©„Éº: ${object.name}`, error);
          }
        }
      });
      
      if (deformedMeshCount > 0) {
        setCurrentBlendShape(`Âº∑Âà∂ÂãïÁöÑÂ§âÂΩ¢ BMI:${bmiValue.toFixed(1)}`);
        console.log(`‚úÖ Âº∑Âà∂Â§âÂΩ¢ÂÆå‰∫Ü: ${deformedMeshCount}ÂÄã„ÅÆ„É°„ÉÉ„Ç∑„É•`);
      } else {
        console.log('üîß „Çπ„Ç±„Éº„É´Â§âÂΩ¢„Å´„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ');
        applyScaleTransformation(Math.min(1.0, (bmiValue - 18.5) / 15));
      }
    }
  };

  // „Çπ„Ç±„Éº„É´Â§âÂΩ¢„Å´„Çà„Çã‰ª£ÊõøÊ©üËÉΩÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
  const applyScaleTransformation = (value: number) => {
    if (!vrmRef.current) return;
    
    console.log('üîß „Çπ„Ç±„Éº„É´Â§âÂΩ¢ÈñãÂßã - value:', value);
    
    // „ÅäËÖπÂë®„Çä„ÇíÊ®°ÂÄ£„Åô„Çã„Çπ„Ç±„Éº„É´Â§âÂΩ¢
    const scaleValue = 1.0 + (value * 0.3); // ÊúÄÂ§ß30%„Åæ„ÅßÊã°Â§ß
    
    vrmRef.current.scene.traverse((object: any) => {
      if (object.isSkinnedMesh) {
        // ËÉ¥‰ΩìÈÉ®ÂàÜ„ÅÆ„Éú„Éº„É≥„ÇíÊé¢„Åó„Å¶„Çπ„Ç±„Éº„É´Ë™øÊï¥
        const boneName = object.name?.toLowerCase();
        if (boneName && (boneName.includes('body') || boneName.includes('spine') || boneName.includes('chest'))) {
          console.log('üéØ ËÉ¥‰Ωì„É°„ÉÉ„Ç∑„É•Áô∫Ë¶ã:', object.name);
          
          // XËª∏ÔºàÂπÖÔºâ„Å®ZËª∏ÔºàÂ••Ë°å„ÅçÔºâ„ÇíÊã°Â§ß„Åó„Å¶„ÅäËÖπ„ÅÆËÜ®„Çâ„Åø„ÇíÊ®°ÂÄ£
          object.scale.setX(scaleValue);
          object.scale.setZ(scaleValue);
          
          console.log(`üìè „Çπ„Ç±„Éº„É´Â§âÂΩ¢ÈÅ©Áî®: ${object.name} -> X:${scaleValue}, Z:${scaleValue}`);
          setCurrentBlendShape(`„Çπ„Ç±„Éº„É´Â§âÂΩ¢ (${(value * 100).toFixed(0)}%)`);
        }
      }
    });
    
    console.log('‚úÖ „Çπ„Ç±„Éº„É´Â§âÂΩ¢ÂÆå‰∫Ü');
  };

  // ÂÄãÂà•„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÉÜ„Çπ„ÉàÈñ¢Êï∞
  const testBlendShape = (name: string, value: number) => {
    if (!vrmRef.current) {
      console.log('‚ùå VRM„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
      return;
    }
    
    console.log(`üß™ „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÉÜ„Çπ„ÉàÈñãÂßã: ${name} = ${value}`);
    let updated = false;
    
    vrmRef.current.scene.traverse((object: any) => {
      if (object.isSkinnedMesh && object.morphTargetDictionary) {
        const dictionary = object.morphTargetDictionary;
        const influences = object.morphTargetInfluences;
        
        if (dictionary[name] !== undefined) {
          const index = dictionary[name];
          const previousValue = influences[index];
          influences[index] = value;
          
          console.log(`‚úÖ „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÊõ¥Êñ∞: ${name} [${index}] ${previousValue} -> ${value}`);
          updated = true;
          
          // ÁèæÂú®„ÅÆ„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÇíÊõ¥Êñ∞
          if (value > 0) {
            setCurrentBlendShape(name);
          }
        }
      }
    });
    
    if (updated) {
      console.log(`‚úÖ „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÉÜ„Çπ„ÉàÂÆå‰∫Ü: ${name}`);
      
      // ÊâãÂãïË™øÊï¥ÂÄ§„ÇÇÊõ¥Êñ∞ÔºàUIÂêåÊúü„ÅÆ„Åü„ÇÅÔºâ
      if (value > 0) {
        setManualBellyValue(value);
        setUseManualAdjustment(true);
      }
    } else {
      console.log(`‚ùå „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: ${name}`);
    }
  };

  // ÂàùÊúüÂåñÔºàÂÆâÂÆöÁâàÔºâ
  useEffect(() => {
    // Êó¢„Å´ÂàùÊúüÂåñÊ∏à„Åø„Åæ„Åü„ÅØ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÊ∏à„Åø„ÅÆÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
    if (initRef.current || isCleanedUpRef.current || !containerRef.current) {
      return;
    }
    
    initRef.current = true;
    console.log('üöÄ VRMViewerÂàùÊúüÂåñÈñãÂßãÔºàÂÆâÂÆöÁâàÔºâ');

    // Three.jsÂü∫Êú¨Ë®≠ÂÆö
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x212121);
    sceneRef.current = scene;

    const camera = new THREE.PerspectiveCamera(
      75,
      containerRef.current.clientWidth / containerRef.current.clientHeight,
      0.1,
      1000
    );
    camera.position.set(0, 1, 5);
    cameraRef.current = camera;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    renderer.setClearColor(0x212121);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // „É©„Ç§„Éà
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    directionalLight.position.set(1, 1, 1);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    const frontLight = new THREE.DirectionalLight(0xffffff, 0.5);
    frontLight.position.set(0, 0, 1);
    scene.add(frontLight);

    // „ÉÜ„Çπ„ÉàÁî®„Ç≠„É•„Éº„Éñ
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const testCube = new THREE.Mesh(geometry, material);
    scene.add(testCube);
    testCubeRef.current = testCube;

    // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„É´„Éº„ÉóÔºà30fpsÂõ∫ÂÆö„ÄÅ„É°„É¢„É™„É™„Éº„ÇØÂØæÁ≠ñÊ∏à„ÅøÔºâ
    let frameCount = 0;
    let lastTime = performance.now();
    const targetFPS = 30;
    const frameInterval = 1000 / targetFPS;
    
    const animate = (currentTime: number) => {
      if (isCleanedUpRef.current) return;
      
      memoryPrevention.safeRequestAnimationFrame(animate);
      
      // FPSÂà∂Èôê: 30fpsÂõ∫ÂÆö
      if (currentTime - lastTime < frameInterval) {
        return;
      }
      lastTime = currentTime;
      
      if (testCubeRef.current) {
        testCubeRef.current.rotation.x += 0.01;
        testCubeRef.current.rotation.y += 0.01;
      }
      
      if (vrmRef.current) {
        vrmRef.current.update(frameInterval / 1000); // Ê≠£Á¢∫„Å™„Éá„É´„Çø„Çø„Ç§„É†
      }
      
      renderer.render(scene, camera);
      
      frameCount++;
      if (frameCount <= 5) {
        console.log(`üé¨ „Éï„É¨„Éº„É† ${frameCount}: 30fpsÂõ∫ÂÆö, „Ç∑„Éº„É≥ÂÜÖ„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÊï∞=${scene.children.length}`);
      }
    };
    animate(performance.now());

    // „É™„Çµ„Ç§„Ç∫Âá¶ÁêÜÔºà„É°„É¢„É™„É™„Éº„ÇØÂØæÁ≠ñÊ∏à„ÅøÔºâ
    const handleResize = () => {
      if (!containerRef.current || !renderer || !camera || isCleanedUpRef.current) return;
      
      camera.aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    };
    
    memoryPrevention.safeAddEventListener(window, 'resize', handleResize);

    console.log('üéØ Three.jsÂàùÊúüÂåñÂÆå‰∫Ü');

    // „Ç∑„É≥„Éó„É´„Å™„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    return () => {
      console.log('üßπ VRMViewer „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó');
      isCleanedUpRef.current = true;
      
      // ÂÖ®„Å¶„ÅÆ„É°„É¢„É™„É™„Éº„ÇØÂØæÁ≠ñ‰ªò„Åç„Çø„Ç§„Éû„Éº„Å®„Ç§„Éô„É≥„Éà„Çí„ÇØ„É™„Ç¢
      memoryPrevention.cleanupAll();
      
      // „É°„ÉÉ„Ç∑„É•Â§âÂΩ¢„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
      if (meshDeformerRef.current) {
        meshDeformerRef.current.cleanup();
        meshDeformerRef.current = null;
      }
      
      // VRM„ÅÆÂÆåÂÖ®„Å™„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÔºà„É°„É¢„É™„É™„Éº„ÇØÂØæÁ≠ñÔºâ
      if (vrmRef.current && sceneRef.current) {
        console.log('üßπ „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Ç¢„É≥„Éû„Ç¶„É≥„ÉàÊôÇ„ÅÆVRM„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÈñãÂßã');
        
        // VRM„ÅÆÂÆåÂÖ®„Å™dispose
        if (vrmRef.current.scene) {
          vrmRef.current.scene.traverse((object: any) => {
            if (object.geometry) {
              object.geometry.dispose();
              console.log('üóëÔ∏è Geometry disposed:', object.name || 'unnamed');
            }
            if (object.material) {
              if (Array.isArray(object.material)) {
                object.material.forEach((mat: any) => {
                  if (mat.map) mat.map.dispose();
                  if (mat.normalMap) mat.normalMap.dispose();
                  if (mat.emissiveMap) mat.emissiveMap.dispose();
                  if (mat.roughnessMap) mat.roughnessMap.dispose();
                  if (mat.metalnessMap) mat.metalnessMap.dispose();
                  mat.dispose();
                });
              } else {
                if (object.material.map) object.material.map.dispose();
                if (object.material.normalMap) object.material.normalMap.dispose();
                if (object.material.emissiveMap) object.material.emissiveMap.dispose();
                if (object.material.roughnessMap) object.material.roughnessMap.dispose();
                if (object.material.metalnessMap) object.material.metalnessMap.dispose();
                object.material.dispose();
              }
              console.log('üóëÔ∏è Material disposed:', object.name || 'unnamed');
            }
          });
        }
        
        sceneRef.current.remove(vrmRef.current.scene);
        vrmRef.current = null;
        console.log('‚úÖ VRM„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÂÆå‰∫Ü');
      }
      
      // „ÉÜ„Çπ„Éà„Ç≠„É•„Éº„Éñ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
      if (testCubeRef.current && sceneRef.current) {
        sceneRef.current.remove(testCubeRef.current);
        testCubeRef.current = null;
      }
      
      // „Ç∑„Éº„É≥„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
      if (sceneRef.current) {
        sceneRef.current.clear();
        sceneRef.current = null;
      }
      
      // „É¨„É≥„ÉÄ„É©„Éº„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
      if (rendererRef.current) {
        if (containerRef.current && rendererRef.current.domElement && containerRef.current.contains(rendererRef.current.domElement)) {
          containerRef.current.removeChild(rendererRef.current.domElement);
        }
        rendererRef.current.dispose();
        rendererRef.current = null;
      }
      
      cameraRef.current = null;
      initRef.current = false;
    };
  }, []); // „Éû„Ç¶„É≥„ÉàÊôÇ„ÅÆ„ÅøÂÆüË°å

  // avatarData„ÅåÂ§âÊõ¥„Åï„Çå„Åü„ÇâVRM„ÇíË™≠„ÅøËæº„ÇÄÔºà„Ç∑„É≥„Éó„É´ÁâàÔºâ
  useEffect(() => {
    if (avatarData && initRef.current && !isCleanedUpRef.current) {
      console.log('üîÑ VRMË™≠„ÅøËæº„Åø:', avatarData.name);
      loadVRM(avatarData.vrmPath);
    }
  }, [avatarData]);

  // Êú™Êù•‰∫àÊ∏¨„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áä∂ÊÖã
  const [animationFrame, setAnimationFrame] = useState<{
    period: string;
    bmi: number;
    weight: number;
    accumulatedKcal: number;
  } | null>(null);
  const [isAnimationActive, setIsAnimationActive] = useState(false);
  const animationIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const fatnessAnimationRef = useRef<number>(0);

  // Êú™Êù•‰∫àÊ∏¨„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÈñãÂßã
  useEffect(() => {
    if (isAnimating && futureBMI.length > 0 && !isAnimationActive) {
      console.log('üé¨ Êú™Êù•‰∫àÊ∏¨„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÈñãÂßã');
      setIsAnimationActive(true);
      
      const periods = [
        { days: 30, label: '1„É∂ÊúàÂæå' },
        { days: 365, label: '1Âπ¥Âæå' },
        { days: 1095, label: '3Âπ¥Âæå' },
        { days: 1825, label: '5Âπ¥Âæå' },
        { days: 3650, label: '10Âπ¥Âæå' }
      ];
      
      let frameIndex = 0;
      
      const runAnimation = () => {
        if (frameIndex < periods.length && frameIndex < futureBMI.length) {
          const prediction = futureBMI[frameIndex];
          const period = periods[frameIndex];
          
          const frameData = {
            period: period.label,
            bmi: prediction.bmi,
            weight: prediction.weight,
            accumulatedKcal: (getExcessCaloriesValue(userData.excessCalories) || 0) * period.days
          };
          
          setAnimationFrame(frameData);
          
          // ÊúüÈñì„Å´Âøú„Åò„Åü„ÅäËÖπ„ÅÆËÜ®„Çâ„ÅøÂ∫¶Âêà„ÅÑ„ÇíÊÆµÈöéÁöÑ„Å´Ë®≠ÂÆö
          let targetFatnessValue = 0;
          if (period.days === 30) {
            // 1„É∂ÊúàÂæå: 20%
            targetFatnessValue = 0.2;
          } else if (period.days === 365) {
            // 1Âπ¥Âæå: 40%
            targetFatnessValue = 0.4;
          } else if (period.days === 1095) {
            // 3Âπ¥Âæå: 60%
            targetFatnessValue = 0.6;
          } else if (period.days === 1825) {
            // 5Âπ¥Âæå: 80%
            targetFatnessValue = 0.8;
          } else if (period.days === 3650) {
            // 10Âπ¥Âæå: 100%
            targetFatnessValue = 1.0;
          }
          
          // „Çπ„É†„Éº„Ç∫„Å™fatness„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
          animateFatnessSmooth(targetFatnessValue);
          
          frameIndex++;
        } else {
          // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÆå‰∫Ü
          console.log('üé¨ Êú™Êù•‰∫àÊ∏¨„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÆå‰∫Ü');
          setIsAnimationActive(false);
          if (animationIntervalRef.current) {
            clearInterval(animationIntervalRef.current);
            animationIntervalRef.current = null;
          }
        }
      };
      
      // ÂàùÂõûÂÆüË°å
      runAnimation();
      
      // 3ÁßíÈñìÈöî„ÅßÂÆüË°å
      animationIntervalRef.current = setInterval(runAnimation, 3000);
    }
  }, [isAnimating, futureBMI, isAnimationActive]);

  // „Çπ„É†„Éº„Ç∫„Å™fatness„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Èñ¢Êï∞
  const animateFatnessSmooth = (targetValue: number) => {
    const startValue = fatnessAnimationRef.current;
    const startTime = Date.now();
    // „É™„Çª„ÉÉ„ÉàÊôÇÔºà0„Å´Êàª„ÇãÊôÇÔºâ„ÅØÈ´òÈÄü„Å´„ÄÅËÜ®„Çâ„Åæ„Åõ„ÇãÊôÇ„ÅØÈÄöÂ∏∏ÈÄüÂ∫¶
    const duration = targetValue === 0 ? 500 : 2500; // „É™„Çª„ÉÉ„ÉàÊôÇ„ÅØ0.5Áßí„ÄÅÈÄöÂ∏∏ÊôÇ„ÅØ2.5Áßí
    
    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // „Ç§„Éº„Ç∏„É≥„Ç∞Èñ¢Êï∞ÔºàÊªë„Çâ„Åã„Å™Â§âÂåñÔºâ
      const easeInOut = progress < 0.5 
        ? 2 * progress * progress 
        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
      
      const currentValue = startValue + (targetValue - startValue) * easeInOut;
      fatnessAnimationRef.current = currentValue;
      
      // VRM„ÅÆfatness„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÇíÊõ¥Êñ∞
      if (vrmRef.current && vrmRef.current.scene) {
        vrmRef.current.scene.traverse((object: any) => {
          if (object.isSkinnedMesh && object.morphTargetDictionary) {
            if (object.morphTargetDictionary['fatness'] !== undefined) {
              const morphIndex = object.morphTargetDictionary['fatness'];
              if (object.morphTargetInfluences && morphIndex < object.morphTargetInfluences.length) {
                object.morphTargetInfluences[morphIndex] = currentValue;
              }
            }
          }
        });
      }
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        console.log(`üé≠ fatnessÊªë„Çâ„ÅãÊõ¥Êñ∞ÂÆå‰∫Ü: ${targetValue}`);
      }
    };
    
    animate();
  };

  // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÅúÊ≠¢ÊôÇ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÔºàËá™Âãï„É™„Çª„ÉÉ„Éà„ÇíÁÑ°ÂäπÂåñÔºâ
  useEffect(() => {
    if (!isAnimating && isAnimationActive) {
      console.log('üé¨ „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÅúÊ≠¢');
      setIsAnimationActive(false);
      
      if (animationIntervalRef.current) {
        clearInterval(animationIntervalRef.current);
        animationIntervalRef.current = null;
      }
      
      // Ëá™Âãï„É™„Çª„ÉÉ„Éà„ÇíÂâäÈô§ - „É¶„Éº„Ç∂„Éº„Åå„ÄåÂÖÉ„Å´Êàª„Çã„Äç„Éú„Çø„É≥„ÇíÊäº„Åô„Åæ„Åß„É™„Çª„ÉÉ„Éà„Åó„Å™„ÅÑ
    }
  }, [isAnimating]);

  function getExcessCaloriesValue(option: string): number {
    switch (option) {
      case 'Â∞ë„Å™„ÅÑ': return -100;
      case 'ÊôÆÈÄö': return 0;
      case 'Â§ö„ÅÑ': return 100;
      default: return 0;
    }
  }

  // BMI„ÅåÂ§âÊõ¥„Åï„Çå„Åü„Çâ‰ΩìÂûã„ÇíÊõ¥Êñ∞ÔºàÂãïÁöÑÂ§âÂΩ¢ÁÑ°ÂäπÂåñ„ÅÆ„Åü„ÇÅ‰∏ÄÊôÇÁöÑ„Å´ÁÑ°ÂäπÔºâ
  // useEffect(() => {
  //   if (currentBMI > 0 && !useManualAdjustment && !isCleanedUpRef.current) {
  //     updateBodyShape(currentBMI);
  //   }
  // }, [currentBMI, useManualAdjustment]);

  // Êú™Êù•„ÅÆBMI‰∫àÊ∏¨„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÔºàÂãïÁöÑÂ§âÂΩ¢ÁÑ°ÂäπÂåñ„ÅÆ„Åü„ÇÅ‰∏ÄÊôÇÁöÑ„Å´ÁÑ°ÂäπÔºâ
  // useEffect(() => {
  //   if (futureBMI.length === 0 || useManualAdjustment || isCleanedUpRef.current) return;

  //   const clearIntervalCallback = memoryPrevention.safeSetInterval(() => {
  //     setCurrentPredictionIndex((prevIndex) => {
  //       const nextIndex = (prevIndex + 1) % futureBMI.length;
  //       const nextBMI = futureBMI[nextIndex].bmi;
  //       updateBodyShape(nextBMI);
  //       return nextIndex;
  //     });
  //   }, 3000);

  //   return clearIntervalCallback;
  // }, [futureBMI, useManualAdjustment, memoryPrevention]);


  return (
    <div className="w-full space-y-4">
      {/* „Ç¢„Éê„Çø„ÉºÊÉÖÂ†±„Éò„ÉÉ„ÉÄ„Éº */}
      <div className={`flex justify-between items-center p-3 rounded-lg transition-all duration-500 ${
        animationFrame 
          ? 'bg-gradient-to-r from-purple-50 to-blue-50 border border-purple-200' 
          : 'bg-transparent'
      }`}>
        <div className="flex items-center space-x-3">
          <div className={`w-12 h-12 bg-gray-100 rounded-lg overflow-hidden transition-all duration-500 ${
            animationFrame ? 'ring-2 ring-purple-300 shadow-lg' : ''
          }`}>
            <img
              src={avatarData.thumbnailPath}
              alt={avatarData.name}
              className="w-full h-full object-cover"
              onError={(e) => {
                e.currentTarget.src = '/placeholder-avatar.png';
              }}
            />
          </div>
          <div>
            <h3 className="font-semibold text-gray-800 flex items-center gap-2">
              {animationFrame ? `${avatarData.name} (${animationFrame.period})` : avatarData.name}
              {animationFrame && (
                <span className="flex items-center gap-1">
                  <div className="animate-pulse w-2 h-2 bg-purple-500 rounded-full"></div>
                  <span className="text-xs text-purple-600 font-medium">‰∫àÊ∏¨‰∏≠</span>
                </span>
              )}
            </h3>
            <p className="text-sm text-gray-600">
              {animationFrame 
                ? `‰∫àÊ∏¨‰ΩìÈáç: ${animationFrame.weight.toFixed(1)}kg (ÁèæÂú®: ${userData.weight}kg)`
                : avatarData.description
              }
            </p>
          </div>
        </div>
        <div className="text-right">
          <p className="text-sm text-gray-500">
            {animationFrame ? `${animationFrame.period}„ÅÆBMI` : 'ÁèæÂú®„ÅÆBMI'}
          </p>
          <p className={`text-lg font-bold transition-all duration-500 ${
            animationFrame ? 'text-purple-600 scale-110' : 'text-blue-600 scale-100'
          }`}>
            {animationFrame ? animationFrame.bmi.toFixed(1) : currentBMI.toFixed(1)}
            {animationFrame && (
              <span className="ml-1 text-xs text-purple-400 animate-bounce">‚ÜóÔ∏è</span>
            )}
          </p>
          {animationFrame && (
            <p className="text-xs text-gray-400 mt-1">
              ÂÖÉ„ÅÆBMI: {currentBMI.toFixed(1)}
            </p>
          )}
        </div>
      </div>

      

      {/* „ÅäËÖπÂë®„Çä„ÅÆÊâãÂãïË™øÊï¥„Ç≥„É≥„Éà„É≠„Éº„É´ÔºàÊ©üËÉΩ„Åó„Å¶„ÅÑ„Å™„ÅÑ„Åü„ÇÅÈùûË°®Á§∫Ôºâ */}
      {/* <div className="bg-gray-50 rounded-lg p-4 space-y-3">
        <div className="flex items-center justify-between">
          <h4 className="font-medium text-gray-700">„ÅäËÖπÂë®„Çä„ÅÆË™øÊï¥Ôºà„É°„É¢„É™„É™„Éº„ÇØÂØæÁ≠ñÊ∏à„ÅøÔºâ</h4>
          <div className="flex items-center space-x-4">
            <label className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={useManualAdjustment}
                onChange={(e) => setUseManualAdjustment(e.target.checked)}
                className="rounded"
              />
              <span className="text-sm text-gray-600">ÊâãÂãïË™øÊï¥</span>
            </label>
          </div>
        </div>
        
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <span className="text-sm text-gray-600">
              üéõÔ∏è „ÅäËÖπ„ÅÆËÜ®„Çâ„Åø{useManualAdjustment ? 'ÔºàÊâãÂãïË™øÊï¥„É¢„Éº„ÉâÔºâ' : 'Ôºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ'}
            </span>
            <span className="text-sm font-medium text-blue-600">
              {(manualBellyValue * 100).toFixed(0)}%
            </span>
          </div>
          <input
            type="range"
            min="0"
            max="1"
            step="0.01"
            value={manualBellyValue}
            onChange={(e) => handleManualBellyChange(parseFloat(e.target.value))}
            className="w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
            style={{
              background: `linear-gradient(to right, #3b82f6 0%, #3b82f6 ${manualBellyValue * 100}%, #e5e7eb ${manualBellyValue * 100}%, #e5e7eb 100%)`
            }}
          />
          <div className="flex justify-between text-xs text-gray-500">
            <span>0% (Ê®ôÊ∫ñ)</span>
            <span>50%</span>
            <span>100% (ÊúÄÂ§ß)</span>
          </div>
          <div className="flex items-center justify-between text-xs">
            <span className={useManualAdjustment ? 'text-green-600' : 'text-gray-500'}>
              {useManualAdjustment ? '‚úÖ ÊâãÂãïË™øÊï¥ÊúâÂäπ' : '‚è∏Ô∏è BMIËá™ÂãïË®àÁÆó‰∏≠'}
            </span>
            <button
              onClick={() => setManualBellyValue(0)}
              className="px-2 py-1 bg-gray-200 hover:bg-gray-300 rounded text-xs"
            >
              „É™„Çª„ÉÉ„Éà
            </button>
          </div>
          
          <div className="grid grid-cols-3 gap-2 text-xs">
            <div className="bg-blue-50 p-2 rounded text-center">
              <div className="font-semibold text-blue-600">BMI</div>
              <div>{currentBMI.toFixed(1)}</div>
            </div>
            <div className="bg-green-50 p-2 rounded text-center">
              <div className="font-semibold text-green-600">„Çπ„É©„Ç§„ÉÄ„Éº</div>
              <div>{(manualBellyValue * 100).toFixed(0)}%</div>
            </div>
            <div className="bg-purple-50 p-2 rounded text-center">
              <div className="font-semibold text-purple-600">ÈÅ©Áî®ÂÄ§</div>
              <div>{manualBellyValue > 0 ? (manualBellyValue * 100).toFixed(0) + '%' : 'BMIÈÄ£Âãï'}</div>
            </div>
          </div>
        </div>
      </div> */}
          
          {/* „Éó„É™„Çª„ÉÉ„Éà„Éú„Çø„É≥ÔºàÂãïÁöÑÂ§âÂΩ¢ÁÑ°ÂäπÂåñ„ÅÆ„Åü„ÇÅÈùûË°®Á§∫Ôºâ */}
          {/* <div className="space-y-1">
            <div className="text-xs text-gray-600 font-medium">„ÇØ„Ç§„ÉÉ„ÇØË®≠ÂÆö:</div>
            <div className="grid grid-cols-5 gap-1">
              {[
                { label: 'Ê®ôÊ∫ñ', value: 0 },
                { label: 'ËªΩÂæÆ', value: 0.2 },
                { label: 'ÊôÆÈÄö', value: 0.4 },
                { label: 'È°ïËëó', value: 0.7 },
                { label: 'ÊúÄÂ§ß', value: 1.0 }
              ].map((preset) => (
                <button
                  key={preset.label}
                  onClick={() => {
                    setManualBellyValue(preset.value);
                    handleManualBellyChange(preset.value);
                  }}
                  className={`px-2 py-1 rounded text-xs transition-colors ${
                    Math.abs(manualBellyValue - preset.value) < 0.05
                      ? 'bg-blue-500 text-white'
                      : 'bg-gray-200 hover:bg-gray-300'
                  }`}
                >
                  {preset.label}
                </button>
              ))}
            </div>
          </div> */}
        
        {/* „É≠„Éº„Éá„Ç£„É≥„Ç∞Áä∂ÊÖã */}
        {isLoading && (
          <div className="bg-blue-50 border border-blue-200 rounded-lg p-3">
            <p className="text-blue-700">üîÑ VRMË™≠„ÅøËæº„Åø‰∏≠...</p>
          </div>
        )}
        
        {/* „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÁä∂ÊÖã„Éá„Éê„ÉÉ„Ç∞ÔºàÈñãÁô∫Áí∞Â¢É„ÅÆ„ÅøÔºâ */}
        {process.env.NODE_ENV === 'development' && (
          <div className="bg-gray-50 border border-gray-200 rounded-lg p-2 text-xs">
            <div className="grid grid-cols-2 gap-1">
              <span className={initRef.current ? 'text-green-600' : 'text-red-600'}>
                ÂàùÊúüÂåñ: {initRef.current ? '‚úÖ' : '‚ùå'}
              </span>
              <span className={!isCleanedUpRef.current ? 'text-green-600' : 'text-red-600'}>
                „Ç¢„ÇØ„ÉÜ„Ç£„Éñ: {!isCleanedUpRef.current ? '‚úÖ' : '‚ùå'}
              </span>
              <span className={!!sceneRef.current ? 'text-green-600' : 'text-red-600'}>
                „Ç∑„Éº„É≥: {!!sceneRef.current ? '‚úÖ' : '‚ùå'}
              </span>
              <span className={!!vrmRef.current ? 'text-green-600' : 'text-red-600'}>
                VRM: {!!vrmRef.current ? '‚úÖ' : '‚ùå'}
              </span>
            </div>
          </div>
        )}
        
        {/* „Ç®„É©„ÉºË°®Á§∫ */}
        {loadingError && (
          <div className="bg-red-50 border border-red-200 rounded-lg p-3">
            <p className="text-red-700">‚ùå {loadingError}</p>
          </div>
        )}
        
        {/* „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†± */}
        {showDebugInfo && (
          <div className="bg-blue-50 border border-blue-200 rounded-lg p-3 space-y-2">
            <h5 className="font-medium text-blue-800">„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±ÔºàÊîπËâØÁâàÔºâ</h5>
            <div className="text-sm text-blue-700 space-y-1">
              <p><strong>Ë®≠ÂÆö„Åï„Çå„Åü„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó:</strong></p>
              <ul className="list-disc pl-5 space-y-1">
                {avatarData.blendShapeNames.belly && (
                  <li>belly: &quot;{avatarData.blendShapeNames.belly}&quot;</li>
                )}
                {avatarData.blendShapeNames.weight && (
                  <li>weight: &quot;{avatarData.blendShapeNames.weight}&quot;</li>
                )}
                {avatarData.blendShapeNames.fat && (
                  <li>fat: &quot;{avatarData.blendShapeNames.fat}&quot;</li>
                )}
              </ul>
              
              {currentBlendShape && (
                <p><strong>ÁèæÂú®‰ΩøÁî®‰∏≠:</strong> {currentBlendShape}</p>
              )}
              
              <p><strong>Âà©Áî®ÂèØËÉΩ„Å™„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÊï∞:</strong> {availableBlendShapes.length}</p>
              
              {availableBlendShapes.length === 0 && (
                <div className="bg-yellow-50 border border-yellow-200 rounded p-2 mt-2">
                  <p className="text-yellow-800 font-semibold">‚ö†Ô∏è „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì</p>
                  <p className="text-yellow-700 text-xs">„Çπ„Ç±„Éº„É´Â§âÂΩ¢„Å´„Çà„Çã‰ª£ÊõøÊ©üËÉΩ„Çí‰ΩøÁî®„Åó„Åæ„Åô</p>
                </div>
              )}
              
              {availableBlendShapes.length > 0 && (
                <details className="mt-2">
                  <summary className="cursor-pointer text-blue-600 hover:text-blue-800">
                    „Åô„Åπ„Å¶„ÅÆ„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„Çí„ÉÜ„Çπ„Éà ({availableBlendShapes.length}ÂÄã)
                  </summary>
                  <div className="mt-2 max-h-40 overflow-y-auto space-y-1">
                    {availableBlendShapes.map((name, index) => (
                      <div key={index} className="flex items-center justify-between bg-gray-50 p-2 rounded text-xs">
                        <span className={name === currentBlendShape ? 'font-bold text-green-600' : 'text-gray-700'}>
                          {name}
                        </span>
                        <div className="flex space-x-1">
                          <button
                            onClick={() => testBlendShape(name, 0.5)}
                            className="px-2 py-1 bg-blue-500 text-white rounded text-xs hover:bg-blue-600"
                          >
                            „ÉÜ„Çπ„Éà
                          </button>
                          <button
                            onClick={() => testBlendShape(name, 0)}
                            className="px-2 py-1 bg-gray-400 text-white rounded text-xs hover:bg-gray-500"
                          >
                            „É™„Çª„ÉÉ„Éà
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                </details>
              )}
              
              <div className="mt-2 p-2 bg-yellow-50 border border-yellow-200 rounded">
                <p className="text-xs text-yellow-700">
                  <strong>„É°„É¢„É™„É™„Éº„ÇØÂØæÁ≠ñ:</strong> „Çø„Ç§„Éû„Éº„Å®„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÅØËá™ÂãïÁöÑ„Å´„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Åï„Çå„Åæ„Åô
                </p>
                <p className="text-xs text-yellow-700 mt-1">
                  „Éá„Éê„ÉÉ„Ç∞: window.debugMemoryLeak.getReport() „Åß„É°„É¢„É™Áä∂Ê≥Å„ÇíÁ¢∫Ë™ç
                </p>
              </div>
              
              {detailedAnalysis && (
                <div className="mt-3 p-3 bg-white rounded border">
                  <h6 className="font-semibold text-gray-800 mb-2">Ë©≥Á¥∞ÂàÜÊûêÁµêÊûú</h6>
                  <div className="text-xs text-gray-600 space-y-1">
                    <p><strong>Á∑è„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÊï∞:</strong> {detailedAnalysis.totalBlendShapes}</p>
                    <p><strong>‰ΩìÂûãÈñ¢ÈÄ£„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó:</strong> {detailedAnalysis.bodyBlendShapes.length}ÂÄã</p>
                    <p><strong>Êé®ÂÆö„É°„É¢„É™‰ΩøÁî®Èáè:</strong> {(detailedAnalysis.totalMemoryUsage / 1024).toFixed(1)}KB</p>
                    
                    {detailedAnalysis.bodyBlendShapes.length > 0 && (
                      <div className="mt-2">
                        <p><strong>‰ΩìÂûãÈñ¢ÈÄ£„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó‰∏ÄË¶ß:</strong></p>
                        <ul className="list-disc pl-4 mt-1 max-h-24 overflow-y-auto">
                          {detailedAnalysis.bodyBlendShapes.map((bs: any, index: number) => (
                            <li key={index} className={bs.name === currentBlendShape ? 'font-bold text-green-600' : ''}>
                              {bs.name}
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                </div>
              )}
            </div>
          </div>
        )}
      
      {/* 3D„Éì„É•„Éº„Ç¢„Éº */}
      <div className="relative">
        <div 
          ref={containerRef}
          className="w-full rounded-lg overflow-hidden border-2 border-gray-200"
          style={{ height: '800px', backgroundColor: '#f0f0f0' }}
        />
        
        {animationFrame && (
          <div className="absolute top-3 left-3 bg-black bg-opacity-70 text-white px-3 py-2 rounded-lg text-sm">
            <div>
              <p className="font-semibold">{animationFrame.period}</p>
              <p className="text-yellow-300">BMI: {animationFrame.bmi.toFixed(1)}</p>
            </div>
          </div>
        )}
        
      {/* „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„Ç≥„É≥„Éà„É≠„Éº„É´„Éë„Éç„É´ */}
      {showDebugInfo && vrmRef.current && (
        <>
          {/* Â∑¶ÂÅ¥„ÅÆ„Ç≥„É≥„Éà„É≠„Éº„É´„Éë„Éç„É´ */}
          <div className="fixed left-0 top-0 h-full w-96 bg-white shadow-2xl flex flex-col z-40">
            <div className="flex items-center justify-between p-4 border-b border-gray-200 bg-gradient-to-r from-blue-50 to-indigo-50">
              <h2 className="text-lg font-bold text-gray-800">üé≠ „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÂà∂Âæ°</h2>
              <button
                onClick={() => setShowDebugInfo(false)}
                className="px-3 py-1 bg-gray-500 text-white text-sm rounded hover:bg-gray-600 transition-colors"
              >
                ‚úï Èñâ„Åò„Çã
              </button>
            </div>
            <div className="flex-1 overflow-hidden">
              <BlendShapeController 
                vrm={vrmRef.current}
                onBlendShapeChange={(name, value) => {
                  console.log(`üé≠ „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÂ§âÊõ¥: ${name} = ${value}`);
                  setCurrentBlendShape(`${name}: ${(value * 100).toFixed(0)}%`);
                  
                  // „ÉÄ„Éü„Éºfatness„ÅÆÂ†¥Âêà„ÄÅÂãïÁöÑÂ§âÂΩ¢„Ç∑„Çπ„ÉÜ„É†„ÅßÂá¶ÁêÜ
                  if (name === 'fatness-dynamic') {
                    const bmiValue = 18.5 + (value * 16.5); // 0-1 „Çí BMI 18.5-35 „Å´Â§âÊèõ
                    console.log(`üß™ „ÉÄ„Éü„Éºfatness -> ÂãïÁöÑÂ§âÂΩ¢: ${value} -> BMI${bmiValue.toFixed(1)}`);
                    applyDynamicMeshDeformation(bmiValue);
                  }
                }}
              />
            </div>
            <div className="p-3 border-t border-gray-200 bg-gray-50 text-xs text-gray-600">
              <div className="flex items-center gap-2 mb-2">
                <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
                <span>Âè≥ÂÅ¥„ÅÆVRM„Éì„É•„Éº„Ç¢„Éº„Åß„É™„Ç¢„É´„Çø„Ç§„É†Á¢∫Ë™ç</span>
              </div>
              {currentBlendShape && (
                <div className="bg-blue-50 p-2 rounded border border-blue-200">
                  <div className="text-xs font-medium text-blue-700">ÁèæÂú®„ÅÆË®≠ÂÆö:</div>
                  <div className="text-sm font-bold text-blue-800">{currentBlendShape}</div>
                </div>
              )}
            </div>
          </div>
          
          {/* Âè≥‰∏ä„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Ç®„É™„Ç¢ */}
          <div className="fixed right-4 top-4 bg-black bg-opacity-70 text-white px-4 py-3 rounded-lg shadow-lg z-30">
            <div className="text-lg font-bold mb-1">üé≠ „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÂà∂Âæ°„É¢„Éº„Éâ</div>
            <div className="text-sm text-gray-300">
              Â∑¶ÂÅ¥„ÅÆ„Éë„Éç„É´„Åß„Çπ„É©„Ç§„ÉÄ„Éº„ÇíË™øÊï¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ
            </div>
          </div>

        </>
      )}

      {/* „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ */}
      {showPerformanceMonitor ? (
        <PerformanceMonitor
          renderer={rendererRef.current}
          isVisible={showPerformanceMonitor}
          onToggle={() => setShowPerformanceMonitor(!showPerformanceMonitor)}
        />
      ) : (
        <PerformanceMiniWidget
          onOpenFull={() => setShowPerformanceMonitor(true)}
        />
      )}
      </div>
    </div>
  );
}