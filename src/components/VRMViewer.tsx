'use client';

import { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
import { AvatarData } from '../utils/avatarConfig';
import { VRMAnalyzer } from '../utils/vrmAnalyzer';
import { VRMDebugAnalyzer } from '../utils/vrmDebugAnalyzer';
import { useMemoryLeakPrevention } from '../utils/memoryLeakPrevention';
import { DynamicMeshDeformer, DeformationOptions } from '../utils/dynamicMeshDeformation';

interface VRMViewerProps {
  currentBMI: number;
  futureBMI: Array<{ period: number; weight: number; bmi: number }>;
  avatarData: AvatarData;
  userData: {
    height: number;
    weight: number;
    age: number;
    gender: 'male' | 'female';
    excessCalories: string;
  };
}

export default function VRMViewer({ currentBMI, futureBMI, avatarData }: VRMViewerProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const initRef = useRef(false);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const vrmRef = useRef<any>(null);
  const testCubeRef = useRef<THREE.Mesh | null>(null);
  const isCleanedUpRef = useRef(false);
  const meshDeformerRef = useRef<DynamicMeshDeformer | null>(null);
  
  // „É°„É¢„É™„É™„Éº„ÇØÈò≤Ê≠¢„Éï„ÉÉ„ÇØ
  const memoryPrevention = useMemoryLeakPrevention();
  
  // Áä∂ÊÖãÁÆ°ÁêÜ
  const [currentPredictionIndex, setCurrentPredictionIndex] = useState(0);
  const [manualBellyValue, setManualBellyValue] = useState(0);
  const [useManualAdjustment, setUseManualAdjustment] = useState(false);
  const [showDebugInfo, setShowDebugInfo] = useState(false);
  const [availableBlendShapes, setAvailableBlendShapes] = useState<string[]>([]);
  const [currentBlendShape, setCurrentBlendShape] = useState<string>('');
  const [detailedAnalysis, setDetailedAnalysis] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [loadingError, setLoadingError] = useState<string>('');

  // VRM„ÇíË™≠„ÅøËæº„ÇÄÈñ¢Êï∞Ôºà„Ç∑„É≥„Éó„É´ÁâàÔºâ
  const loadVRM = async (vrmPath: string) => {
    // Âü∫Êú¨„ÉÅ„Çß„ÉÉ„ÇØ
    if (!sceneRef.current || !cameraRef.current || isCleanedUpRef.current || !initRef.current) {
      console.log('‚ùå VRMË™≠„ÅøËæº„Åø‰∏≠Ê≠¢: Êù°‰ª∂‰∏çÊ∫ÄË∂≥');
      return;
    }

    setIsLoading(true);
    setLoadingError('');
    console.log('üì¶ VRMË™≠„ÅøËæº„ÅøÈñãÂßã:', vrmPath);

    try {
      const loader = new GLTFLoader();
      loader.register((parser) => new VRMLoaderPlugin(parser));

      const gltf = await loader.loadAsync(vrmPath);
      
      // Ë™≠„ÅøËæº„ÅøÂæå„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„ÉÅ„Çß„ÉÉ„ÇØ
      if (isCleanedUpRef.current || !initRef.current) {
        console.log('‚ùå VRMË™≠„ÅøËæº„Åø‰∏≠Êñ≠: „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÁä∂ÊÖãÂ§âÊõ¥');
        setIsLoading(false);
        return;
      }

      console.log('‚úÖ VRMË™≠„ÅøËæº„ÅøÊàêÂäü:', gltf);
      const vrm = gltf.userData.vrm;
      
      let sceneToAdd = null;
      if (vrm && sceneRef.current) {
        sceneToAdd = vrm.scene;
      } else if (gltf.scene && sceneRef.current) {
        sceneToAdd = gltf.scene;
      } else {
        throw new Error('VRM„ÇÇGLTF„Ç∑„Éº„É≥„ÇÇÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì');
      }
      
      if (sceneToAdd && sceneRef.current) {
        // Êó¢Â≠ò„ÅÆVRM„ÇíÂâäÈô§
        if (vrmRef.current && sceneRef.current) {
          sceneRef.current.remove(vrmRef.current.scene);
        }
        
        // „ÉÜ„Çπ„Éà„Ç≠„É•„Éº„Éñ„ÇíÂâäÈô§
        if (testCubeRef.current && sceneRef.current) {
          sceneRef.current.remove(testCubeRef.current);
          testCubeRef.current = null;
        }
        
        vrmRef.current = vrm;
        sceneRef.current.add(sceneToAdd);
        
        // VRM„ÅÆÂ†¥Âêà„ÅÆ„ÅøVRMUtils„ÇíÈÅ©Áî®
        if (vrm) {
          VRMUtils.rotateVRM0(vrm);
        }
        
        // ÂãïÁöÑ„É°„ÉÉ„Ç∑„É•Â§âÂΩ¢„ÅÆÂàùÊúüÂåñ
        if (!meshDeformerRef.current) {
          meshDeformerRef.current = new DynamicMeshDeformer();
        }
        
        // ‰Ωì„É°„ÉÉ„Ç∑„É•„ÅÆÂÖÉ„Éá„Éº„Çø„Çí‰øùÂ≠ò
        let bodyMeshCount = 0;
        sceneToAdd.traverse((object: any) => {
          if (object.isSkinnedMesh && object.name) {
            const objName = object.name.toLowerCase();
            const isBodyMesh = objName.includes('body') || 
                              objName.includes('merged') ||
                              (!objName.includes('face') && !objName.includes('head') && !objName.includes('hair'));
            
            if (isBodyMesh) {
              meshDeformerRef.current!.saveOriginalVertices(object);
              bodyMeshCount++;
            }
          }
        });
        console.log(`üéØ ‰Ωì„É°„ÉÉ„Ç∑„É•‰øùÂ≠òÂÆå‰∫Ü: ${bodyMeshCount}ÂÄã`);
        
        // „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÂàÜÊûê„ÇíÂÆüË°å
        await analyzeBlendShapes(sceneToAdd, vrm);
        
        // „Ç´„É°„É©‰ΩçÁΩÆË™øÊï¥
        adjustCameraPosition(sceneToAdd);
        
        // ÂàùÊúüBMIÂÄ§„Åß‰ΩìÂûãÊõ¥Êñ∞
        if (currentBMI > 0 && !isCleanedUpRef.current) {
          setTimeout(() => {
            if (!isCleanedUpRef.current) {
              updateBodyShape(currentBMI);
            }
          }, 100);
        }
      }
    } catch (error) {
      console.error('‚ùå VRMË™≠„ÅøËæº„ÅøÂ§±Êïó:', error);
      if (!isCleanedUpRef.current) {
        setLoadingError(`VRMË™≠„ÅøËæº„Åø„Ç®„É©„Éº: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    } finally {
      if (!isCleanedUpRef.current) {
        setIsLoading(false);
      }
    }
  };

  // „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÂàÜÊûêÈñ¢Êï∞
  const analyzeBlendShapes = async (sceneToAdd: THREE.Object3D, vrm: any) => {
    const allBlendShapes = new Map<string, number>();
    let totalBlendShapes = 0;
    let bodyBlendShapes = 0;
    
    sceneToAdd.traverse((object: any) => {
      if (object.isSkinnedMesh && object.morphTargetDictionary) {
        const blendShapeNames = Object.keys(object.morphTargetDictionary);
        totalBlendShapes += blendShapeNames.length;
        
        blendShapeNames.forEach(name => {
          const index = object.morphTargetDictionary[name];
          const currentValue = object.morphTargetInfluences ? object.morphTargetInfluences[index] : 0;
          allBlendShapes.set(name, currentValue);
          
          const lowerName = name.toLowerCase();
          const isBodyRelated = lowerName.includes('belly') || lowerName.includes('fat') || 
                              lowerName.includes('weight') || lowerName.includes('body') ||
                              lowerName.includes('chest') || lowerName.includes('waist') ||
                              lowerName.includes('hip') || lowerName.includes('muscle');
          
          if (isBodyRelated) {
            bodyBlendShapes++;
          }
        });
      }
    });
    
    console.log(`üìä „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó: ÂÖ®${totalBlendShapes}ÂÄã (‰ΩìÂûãÈñ¢ÈÄ£: ${bodyBlendShapes}ÂÄã)`);
    
    // VRMAnalyzer„Çí‰ΩøÁî®„Åó„ÅüË©≥Á¥∞ÂàÜÊûê
    try {
      const analysisResult = VRMAnalyzer.analyzeVRMBlendShapes(vrm);
      console.log('üìà VRMAnalyzerÂàÜÊûêÁµêÊûú:', analysisResult);
      
      // UI„Å´Ë°®Á§∫„Åô„Çã„Åü„ÇÅ„ÅÆÊÉÖÂ†±„Çí‰øùÂ≠ò
      setAvailableBlendShapes(Array.from(allBlendShapes.keys()));
      
      // Á∞°Áï•Âåñ„Åï„Çå„ÅüË©≥Á¥∞ÂàÜÊûêÁµêÊûú„Çí‰ΩúÊàê
      const bodyBlendShapes = Array.from(allBlendShapes.keys()).filter(name => {
        const lowerName = name.toLowerCase();
        return lowerName.includes('belly') || lowerName.includes('weight') || 
               lowerName.includes('fat') || lowerName.includes('body') ||
               lowerName.includes('chest') || lowerName.includes('waist') ||
               lowerName.includes('hip') || lowerName.includes('muscle');
      });
      
      const detailedAnalysisResult = {
        totalBlendShapes: allBlendShapes.size,
        bodyBlendShapes: bodyBlendShapes.map(name => ({ name, meshName: 'mesh' })),
        faceBlendShapes: [],
        emotionBlendShapes: [],
        unknownBlendShapes: [],
        meshes: [{ name: 'VRM Mesh', blendShapeCount: allBlendShapes.size }],
        totalMemoryUsage: allBlendShapes.size * 1024
      };
      
      setDetailedAnalysis(detailedAnalysisResult);
      
      // ‰ΩøÁî®„Åô„Çã„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÇíÊ±∫ÂÆö
      let usedBlendShape = '';
      const configuredShapes = [
        avatarData.blendShapeNames.belly,
        avatarData.blendShapeNames.weight,
        avatarData.blendShapeNames.fat
      ].filter(Boolean);
      
      for (const shapeName of configuredShapes) {
        if (allBlendShapes.has(shapeName!)) {
          usedBlendShape = shapeName!;
          break;
        }
      }
      
      // Ë®≠ÂÆö„Åï„Çå„Åü„ÇÇ„ÅÆ„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅÆËá™ÂãïÊ§úÂá∫
      if (!usedBlendShape && bodyBlendShapes.length > 0) {
        usedBlendShape = bodyBlendShapes[0];
        console.log('üîÑ Ëá™ÂãïÊ§úÂá∫„Åï„Çå„Åü„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó:', usedBlendShape);
      }
      
      setCurrentBlendShape(usedBlendShape);
      console.log('üéØ ÊúÄÁµÇÁöÑ„Å´‰ΩøÁî®„Åô„Çã„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó:', usedBlendShape || '„Å™„Åó');
      
    } catch (error) {
      console.error('‚ùå VRMAnalyzerÂàÜÊûê„Ç®„É©„Éº:', error);
    }
  };

  // „Ç´„É°„É©‰ΩçÁΩÆË™øÊï¥
  const adjustCameraPosition = (sceneToAdd: THREE.Object3D) => {
    const box = new THREE.Box3().setFromObject(sceneToAdd);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    
    console.log('üìê VRM„Éê„Ç¶„É≥„Éá„Ç£„É≥„Ç∞„Éú„ÉÉ„ÇØ„Çπ - center:', center, 'size:', size, 'maxDim:', maxDim);
    
    let cameraX, cameraY, cameraZ;
    if (maxDim < 0.5) {
      cameraX = 0;
      cameraY = center.y;
      cameraZ = 1.5;
    } else if (maxDim < 2.0) {
      cameraX = center.x;
      cameraY = center.y;
      cameraZ = maxDim * 1.5;
    } else {
      const fov = cameraRef.current!.fov * (Math.PI / 180);
      cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * 1.2;
      cameraX = center.x;
      cameraY = center.y + size.y / 4;
    }
    
    cameraRef.current!.position.set(cameraX, cameraY, cameraZ);
    cameraRef.current!.lookAt(center);
    
    // „Éï„É©„Çπ„Çø„É†„Ç´„É™„É≥„Ç∞„ÇíÁÑ°ÂäπÂåñ
    sceneToAdd.traverse((child: any) => {
      if (child.isMesh) {
        child.frustumCulled = false;
      }
    });
  };

  // BMI„Å´Âü∫„Å•„ÅÑ„Å¶‰ΩìÂûã„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
  const updateBodyShape = (bmiValue: number) => {
    if (!vrmRef.current || isCleanedUpRef.current) return;
    
    console.log('üîç updateBodyShapeÂÆüË°åÈñãÂßã - BMI:', bmiValue);
    
    // „Åæ„ÅöÂãïÁöÑ„É°„ÉÉ„Ç∑„É•Â§âÂΩ¢„ÇíË©¶Ë°å
    if (meshDeformerRef.current) {
      applyDynamicMeshDeformation(bmiValue);
      return;
    }
    
    vrmRef.current.scene.traverse((object: any) => {
      if (object.isSkinnedMesh && object.morphTargetDictionary) {
        const blendShapeNames = avatarData.blendShapeNames;
        let bellyIndex = undefined;
        let usedBlendShapeName = '';

        // Ë®≠ÂÆö„Åï„Çå„Åü„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÇíÊé¢„Åô
        if (blendShapeNames.belly && object.morphTargetDictionary[blendShapeNames.belly] !== undefined) {
          bellyIndex = object.morphTargetDictionary[blendShapeNames.belly];
          usedBlendShapeName = blendShapeNames.belly;
        } else if (blendShapeNames.weight && object.morphTargetDictionary[blendShapeNames.weight] !== undefined) {
          bellyIndex = object.morphTargetDictionary[blendShapeNames.weight];
          usedBlendShapeName = blendShapeNames.weight;
        } else if (blendShapeNames.fat && object.morphTargetDictionary[blendShapeNames.fat] !== undefined) {
          bellyIndex = object.morphTargetDictionary[blendShapeNames.fat];
          usedBlendShapeName = blendShapeNames.fat;
        } else {
          // Ëá™ÂãïÊ§úÂá∫
          const availableBlendShapes = Object.keys(object.morphTargetDictionary);
          const potentialBodyBlendShapes = availableBlendShapes.filter(name => {
            const lowerName = name.toLowerCase();
            return lowerName.includes('belly') || lowerName.includes('fat') || 
                   lowerName.includes('weight') || lowerName.includes('body') ||
                   lowerName.includes('chest') || lowerName.includes('waist') ||
                   lowerName.includes('hip') || lowerName.includes('muscle');
          });
          
          if (potentialBodyBlendShapes.length > 0) {
            bellyIndex = object.morphTargetDictionary[potentialBodyBlendShapes[0]];
            usedBlendShapeName = potentialBodyBlendShapes[0];
          }
        }
        
        if (bellyIndex !== undefined) {
          let blendValue = 0;
          
          // ÊâãÂãïË™øÊï¥ÂÄ§„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂ∏∏„Å´ÂÑ™ÂÖà
          if (manualBellyValue > 0) {
            blendValue = manualBellyValue;
            console.log('üéõÔ∏è ÊâãÂãïË™øÊï¥ÂÄ§„Çí‰ΩøÁî®:', blendValue);
          } else if (useManualAdjustment) {
            blendValue = manualBellyValue;
            console.log('üîß ÊâãÂãïË™øÊï¥„É¢„Éº„Éâ:', blendValue);
          } else {
            // BMIËá™ÂãïË®àÁÆó
            if (bmiValue <= 25) {
              blendValue = 0;
            } else if (bmiValue > 25 && bmiValue <= 30) {
              blendValue = ((bmiValue - 25) / 5) * 0.5;
            } else if (bmiValue > 30) {
              blendValue = Math.min(0.5 + ((bmiValue - 30) / 10) * 0.5, 1.0);
            }
            console.log('üßÆ BMIËá™ÂãïË®àÁÆó:', bmiValue, '->', blendValue);
          }
          
          const previousValue = object.morphTargetInfluences[bellyIndex];
          object.morphTargetInfluences[bellyIndex] = blendValue;
          
          console.log('üìà „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÂÄ§„ÇíÊõ¥Êñ∞:', usedBlendShapeName, 'Ââç„ÅÆÂÄ§:', previousValue, 'Êñ∞„Åó„ÅÑÂÄ§:', blendValue);
          setCurrentBlendShape(usedBlendShapeName);
        }
      }
    });
  };

  // ÊâãÂãï„Åß„ÅäËÖπÂë®„Çä„ÇíË™øÊï¥„Åô„ÇãÈñ¢Êï∞
  const handleManualBellyChange = (value: number) => {
    setManualBellyValue(value);
    
    if (vrmRef.current) {
      forceUpdateBlendShape(value);
    }
  };
  
  // Âº∑Âà∂ÁöÑ„Å´„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞Ôºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ
  const forceUpdateBlendShape = (value: number) => {
    if (!vrmRef.current) return;
    
    let updated = false;
    
    vrmRef.current.scene.traverse((object: any) => {
      if (object.isSkinnedMesh && object.morphTargetDictionary) {
        const dictionary = object.morphTargetDictionary;
        const influences = object.morphTargetInfluences;
        
        // Ë®≠ÂÆö„Åï„Çå„Åü„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÇíË©¶Ë°å
        const configuredShapes = [
          avatarData.blendShapeNames.belly,
          avatarData.blendShapeNames.weight,
          avatarData.blendShapeNames.fat
        ].filter(Boolean);
        
        for (const shapeName of configuredShapes) {
          if (dictionary[shapeName!] !== undefined) {
            const index = dictionary[shapeName!];
            influences[index] = value;
            updated = true;
            setCurrentBlendShape(shapeName!);
            return;
          }
        }
        
        // ‰ΩìÂûãÈñ¢ÈÄ£„ÇíËá™ÂãïÊ§úÂá∫
        if (!updated) {
          const bodyShapes = Object.keys(dictionary).filter(name => {
            const lowerName = name.toLowerCase();
            return lowerName.includes('belly') || lowerName.includes('weight') || 
                   lowerName.includes('fat') || lowerName.includes('body') ||
                   lowerName.includes('chest') || lowerName.includes('waist') ||
                   lowerName.includes('hip') || lowerName.includes('muscle');
          });
          
          if (bodyShapes.length > 0) {
            const shapeName = bodyShapes[0];
            const index = dictionary[shapeName];
            influences[index] = value;
            updated = true;
            setCurrentBlendShape(shapeName);
          }
        }
      }
    });
    
    if (!updated) {
      // ÂãïÁöÑ„É°„ÉÉ„Ç∑„É•Â§âÂΩ¢„ÇíÂÆüË°å
      const bmiValue = 18.5 + (value * 16.5);
      console.log(`üîß ÂãïÁöÑÂ§âÂΩ¢ÂÆüË°å: „Çπ„É©„Ç§„ÉÄ„Éº${(value*100).toFixed(0)}% -> BMI${bmiValue.toFixed(1)}`);
      
      if (!meshDeformerRef.current) {
        meshDeformerRef.current = new DynamicMeshDeformer();
      }
      applyDynamicMeshDeformation(bmiValue);
    }
  };

  // ÂãïÁöÑ„É°„ÉÉ„Ç∑„É•Â§âÂΩ¢„Å´„Çà„Çã‰ΩìÂûãÂ§âÊõ¥ÔºàÊñ∞Ê©üËÉΩÔºâ
  const applyDynamicMeshDeformation = (bmiValue: number) => {
    if (!vrmRef.current || !meshDeformerRef.current) return;
    
    const deformationOptions = meshDeformerRef.current.calculateDeformationFromBMI(bmiValue);
    let deformedMeshCount = 0;
    
    vrmRef.current.scene.traverse((object: any) => {
      if (object.isSkinnedMesh && object.name) {
        const objName = object.name.toLowerCase();
        const isBodyMesh = !objName.includes('face') && !objName.includes('head') && !objName.includes('hair');
        
        if (isBodyMesh) {
          meshDeformerRef.current!.deformMesh(object, deformationOptions);
          deformedMeshCount++;
        }
      }
    });
    
    if (deformedMeshCount > 0) {
      setCurrentBlendShape(`ÂãïÁöÑÂ§âÂΩ¢ BMI:${bmiValue.toFixed(1)}`);
      console.log(`‚úÖ ÂãïÁöÑÂ§âÂΩ¢ÂÆå‰∫Ü: ${deformedMeshCount}ÂÄã„ÅÆ„É°„ÉÉ„Ç∑„É•`);
    } else {
      // Âº∑Âà∂ÁöÑ„Å´ÂÖ®SkinnedMesh„Å´ÈÅ©Áî®
      vrmRef.current.scene.traverse((object: any) => {
        if (object.isSkinnedMesh && object.geometry?.attributes?.position) {
          try {
            meshDeformerRef.current!.saveOriginalVertices(object);
            meshDeformerRef.current!.deformMesh(object, deformationOptions);
            deformedMeshCount++;
          } catch (error) {
            console.error(`Â§âÂΩ¢„Ç®„É©„Éº: ${object.name}`, error);
          }
        }
      });
      
      if (deformedMeshCount > 0) {
        setCurrentBlendShape(`Âº∑Âà∂ÂãïÁöÑÂ§âÂΩ¢ BMI:${bmiValue.toFixed(1)}`);
        console.log(`‚úÖ Âº∑Âà∂Â§âÂΩ¢ÂÆå‰∫Ü: ${deformedMeshCount}ÂÄã„ÅÆ„É°„ÉÉ„Ç∑„É•`);
      } else {
        console.log('üîß „Çπ„Ç±„Éº„É´Â§âÂΩ¢„Å´„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ');
        applyScaleTransformation(Math.min(1.0, (bmiValue - 18.5) / 15));
      }
    }
  };

  // „Çπ„Ç±„Éº„É´Â§âÂΩ¢„Å´„Çà„Çã‰ª£ÊõøÊ©üËÉΩÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
  const applyScaleTransformation = (value: number) => {
    if (!vrmRef.current) return;
    
    console.log('üîß „Çπ„Ç±„Éº„É´Â§âÂΩ¢ÈñãÂßã - value:', value);
    
    // „ÅäËÖπÂë®„Çä„ÇíÊ®°ÂÄ£„Åô„Çã„Çπ„Ç±„Éº„É´Â§âÂΩ¢
    const scaleValue = 1.0 + (value * 0.3); // ÊúÄÂ§ß30%„Åæ„ÅßÊã°Â§ß
    
    vrmRef.current.scene.traverse((object: any) => {
      if (object.isSkinnedMesh) {
        // ËÉ¥‰ΩìÈÉ®ÂàÜ„ÅÆ„Éú„Éº„É≥„ÇíÊé¢„Åó„Å¶„Çπ„Ç±„Éº„É´Ë™øÊï¥
        const boneName = object.name?.toLowerCase();
        if (boneName && (boneName.includes('body') || boneName.includes('spine') || boneName.includes('chest'))) {
          console.log('üéØ ËÉ¥‰Ωì„É°„ÉÉ„Ç∑„É•Áô∫Ë¶ã:', object.name);
          
          // XËª∏ÔºàÂπÖÔºâ„Å®ZËª∏ÔºàÂ••Ë°å„ÅçÔºâ„ÇíÊã°Â§ß„Åó„Å¶„ÅäËÖπ„ÅÆËÜ®„Çâ„Åø„ÇíÊ®°ÂÄ£
          object.scale.setX(scaleValue);
          object.scale.setZ(scaleValue);
          
          console.log(`üìè „Çπ„Ç±„Éº„É´Â§âÂΩ¢ÈÅ©Áî®: ${object.name} -> X:${scaleValue}, Z:${scaleValue}`);
          setCurrentBlendShape(`„Çπ„Ç±„Éº„É´Â§âÂΩ¢ (${(value * 100).toFixed(0)}%)`);
        }
      }
    });
    
    console.log('‚úÖ „Çπ„Ç±„Éº„É´Â§âÂΩ¢ÂÆå‰∫Ü');
  };

  // ÂÄãÂà•„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÉÜ„Çπ„ÉàÈñ¢Êï∞
  const testBlendShape = (name: string, value: number) => {
    if (!vrmRef.current) {
      console.log('‚ùå VRM„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
      return;
    }
    
    console.log(`üß™ „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÉÜ„Çπ„ÉàÈñãÂßã: ${name} = ${value}`);
    let updated = false;
    
    vrmRef.current.scene.traverse((object: any) => {
      if (object.isSkinnedMesh && object.morphTargetDictionary) {
        const dictionary = object.morphTargetDictionary;
        const influences = object.morphTargetInfluences;
        
        if (dictionary[name] !== undefined) {
          const index = dictionary[name];
          const previousValue = influences[index];
          influences[index] = value;
          
          console.log(`‚úÖ „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÊõ¥Êñ∞: ${name} [${index}] ${previousValue} -> ${value}`);
          updated = true;
          
          // ÁèæÂú®„ÅÆ„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÇíÊõ¥Êñ∞
          if (value > 0) {
            setCurrentBlendShape(name);
          }
        }
      }
    });
    
    if (updated) {
      console.log(`‚úÖ „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÉÜ„Çπ„ÉàÂÆå‰∫Ü: ${name}`);
      
      // ÊâãÂãïË™øÊï¥ÂÄ§„ÇÇÊõ¥Êñ∞ÔºàUIÂêåÊúü„ÅÆ„Åü„ÇÅÔºâ
      if (value > 0) {
        setManualBellyValue(value);
        setUseManualAdjustment(true);
      }
    } else {
      console.log(`‚ùå „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: ${name}`);
    }
  };

  // ÂàùÊúüÂåñÔºàÂÆâÂÆöÁâàÔºâ
  useEffect(() => {
    // Êó¢„Å´ÂàùÊúüÂåñÊ∏à„Åø„Åæ„Åü„ÅØ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÊ∏à„Åø„ÅÆÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
    if (initRef.current || isCleanedUpRef.current || !containerRef.current) {
      return;
    }
    
    initRef.current = true;
    console.log('üöÄ VRMViewerÂàùÊúüÂåñÈñãÂßãÔºàÂÆâÂÆöÁâàÔºâ');

    // Three.jsÂü∫Êú¨Ë®≠ÂÆö
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x212121);
    sceneRef.current = scene;

    const camera = new THREE.PerspectiveCamera(
      75,
      containerRef.current.clientWidth / containerRef.current.clientHeight,
      0.1,
      1000
    );
    camera.position.set(0, 1, 5);
    cameraRef.current = camera;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    renderer.setClearColor(0x212121);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // „É©„Ç§„Éà
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    directionalLight.position.set(1, 1, 1);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    const frontLight = new THREE.DirectionalLight(0xffffff, 0.5);
    frontLight.position.set(0, 0, 1);
    scene.add(frontLight);

    // „ÉÜ„Çπ„ÉàÁî®„Ç≠„É•„Éº„Éñ
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const testCube = new THREE.Mesh(geometry, material);
    scene.add(testCube);
    testCubeRef.current = testCube;

    // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„É´„Éº„ÉóÔºà„É°„É¢„É™„É™„Éº„ÇØÂØæÁ≠ñÊ∏à„ÅøÔºâ
    let frameCount = 0;
    const animate = () => {
      if (isCleanedUpRef.current) return;
      
      memoryPrevention.safeRequestAnimationFrame(animate);
      
      if (testCubeRef.current) {
        testCubeRef.current.rotation.x += 0.01;
        testCubeRef.current.rotation.y += 0.01;
      }
      
      if (vrmRef.current) {
        vrmRef.current.update(0.016);
      }
      
      renderer.render(scene, camera);
      
      frameCount++;
      if (frameCount <= 5) {
        console.log(`üé¨ „Éï„É¨„Éº„É† ${frameCount}: „Ç∑„Éº„É≥ÂÜÖ„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÊï∞=${scene.children.length}`);
      }
    };
    animate();

    // „É™„Çµ„Ç§„Ç∫Âá¶ÁêÜÔºà„É°„É¢„É™„É™„Éº„ÇØÂØæÁ≠ñÊ∏à„ÅøÔºâ
    const handleResize = () => {
      if (!containerRef.current || !renderer || !camera || isCleanedUpRef.current) return;
      
      camera.aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    };
    
    memoryPrevention.safeAddEventListener(window, 'resize', handleResize);

    console.log('üéØ Three.jsÂàùÊúüÂåñÂÆå‰∫Ü');

    // „Ç∑„É≥„Éó„É´„Å™„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    return () => {
      console.log('üßπ VRMViewer „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó');
      isCleanedUpRef.current = true;
      
      // ÂÖ®„Å¶„ÅÆ„É°„É¢„É™„É™„Éº„ÇØÂØæÁ≠ñ‰ªò„Åç„Çø„Ç§„Éû„Éº„Å®„Ç§„Éô„É≥„Éà„Çí„ÇØ„É™„Ç¢
      memoryPrevention.cleanupAll();
      
      // „É°„ÉÉ„Ç∑„É•Â§âÂΩ¢„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
      if (meshDeformerRef.current) {
        meshDeformerRef.current.cleanup();
        meshDeformerRef.current = null;
      }
      
      // VRM„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
      if (vrmRef.current && sceneRef.current) {
        sceneRef.current.remove(vrmRef.current.scene);
        vrmRef.current = null;
      }
      
      // „ÉÜ„Çπ„Éà„Ç≠„É•„Éº„Éñ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
      if (testCubeRef.current && sceneRef.current) {
        sceneRef.current.remove(testCubeRef.current);
        testCubeRef.current = null;
      }
      
      // „Ç∑„Éº„É≥„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
      if (sceneRef.current) {
        sceneRef.current.clear();
        sceneRef.current = null;
      }
      
      // „É¨„É≥„ÉÄ„É©„Éº„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
      if (rendererRef.current) {
        if (containerRef.current && rendererRef.current.domElement && containerRef.current.contains(rendererRef.current.domElement)) {
          containerRef.current.removeChild(rendererRef.current.domElement);
        }
        rendererRef.current.dispose();
        rendererRef.current = null;
      }
      
      cameraRef.current = null;
      initRef.current = false;
    };
  }, []); // „Éû„Ç¶„É≥„ÉàÊôÇ„ÅÆ„ÅøÂÆüË°å

  // avatarData„ÅåÂ§âÊõ¥„Åï„Çå„Åü„ÇâVRM„ÇíË™≠„ÅøËæº„ÇÄÔºà„Ç∑„É≥„Éó„É´ÁâàÔºâ
  useEffect(() => {
    if (avatarData && initRef.current && !isCleanedUpRef.current) {
      console.log('üîÑ VRMË™≠„ÅøËæº„Åø:', avatarData.name);
      loadVRM(avatarData.vrmPath);
    }
  }, [avatarData]);

  // BMI„ÅåÂ§âÊõ¥„Åï„Çå„Åü„Çâ‰ΩìÂûã„ÇíÊõ¥Êñ∞
  useEffect(() => {
    if (currentBMI > 0 && !useManualAdjustment && !isCleanedUpRef.current) {
      updateBodyShape(currentBMI);
    }
  }, [currentBMI, useManualAdjustment]);

  // Êú™Êù•„ÅÆBMI‰∫àÊ∏¨„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ôºà„É°„É¢„É™„É™„Éº„ÇØÂØæÁ≠ñÊ∏à„ÅøÔºâ
  useEffect(() => {
    if (futureBMI.length === 0 || useManualAdjustment || isCleanedUpRef.current) return;

    const clearIntervalCallback = memoryPrevention.safeSetInterval(() => {
      setCurrentPredictionIndex((prevIndex) => {
        const nextIndex = (prevIndex + 1) % futureBMI.length;
        const nextBMI = futureBMI[nextIndex].bmi;
        updateBodyShape(nextBMI);
        return nextIndex;
      });
    }, 3000);

    return clearIntervalCallback;
  }, [futureBMI, useManualAdjustment, memoryPrevention]);

  return (
    <div className="w-full space-y-4">
      {/* „Ç¢„Éê„Çø„ÉºÊÉÖÂ†±„Éò„ÉÉ„ÉÄ„Éº */}
      <div className="flex justify-between items-center">
        <div className="flex items-center space-x-3">
          <div className="w-12 h-12 bg-gray-100 rounded-lg overflow-hidden">
            <img
              src={avatarData.thumbnailPath}
              alt={avatarData.name}
              className="w-full h-full object-cover"
              onError={(e) => {
                e.currentTarget.src = '/placeholder-avatar.png';
              }}
            />
          </div>
          <div>
            <h3 className="font-semibold text-gray-800">{avatarData.name}</h3>
            <p className="text-sm text-gray-600">{avatarData.description}</p>
          </div>
        </div>
        <div className="text-right">
          <p className="text-sm text-gray-500">ÁèæÂú®„ÅÆBMI</p>
          <p className="text-lg font-bold text-blue-600">{currentBMI.toFixed(1)}</p>
        </div>
      </div>
      
      {/* „ÅäËÖπÂë®„Çä„ÅÆÊâãÂãïË™øÊï¥„Ç≥„É≥„Éà„É≠„Éº„É´ */}
      <div className="bg-gray-50 rounded-lg p-4 space-y-3">
        <div className="flex items-center justify-between">
          <h4 className="font-medium text-gray-700">„ÅäËÖπÂë®„Çä„ÅÆË™øÊï¥Ôºà„É°„É¢„É™„É™„Éº„ÇØÂØæÁ≠ñÊ∏à„ÅøÔºâ</h4>
          <div className="flex items-center space-x-4">
            <label className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={showDebugInfo}
                onChange={(e) => setShowDebugInfo(e.target.checked)}
                className="rounded"
              />
              <span className="text-sm text-gray-600">„Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±</span>
            </label>
            <label className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={useManualAdjustment}
                onChange={(e) => setUseManualAdjustment(e.target.checked)}
                className="rounded"
              />
              <span className="text-sm text-gray-600">ÊâãÂãïË™øÊï¥</span>
            </label>
          </div>
        </div>
        
        {/* „Éá„Éê„ÉÉ„Ç∞Áî®„Çπ„É©„Ç§„ÉÄ„ÉºÔºàÂ∏∏„Å´Ë°®Á§∫Ôºâ */}
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <span className="text-sm text-gray-600">
              üéõÔ∏è „ÅäËÖπ„ÅÆËÜ®„Çâ„Åø{useManualAdjustment ? 'ÔºàÊâãÂãïË™øÊï¥„É¢„Éº„ÉâÔºâ' : 'Ôºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ'}
            </span>
            <span className="text-sm font-medium text-blue-600">
              {(manualBellyValue * 100).toFixed(0)}%
            </span>
          </div>
          <input
            type="range"
            min="0"
            max="1"
            step="0.01"
            value={manualBellyValue}
            onChange={(e) => handleManualBellyChange(parseFloat(e.target.value))}
            className="w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
            style={{
              background: `linear-gradient(to right, #3b82f6 0%, #3b82f6 ${manualBellyValue * 100}%, #e5e7eb ${manualBellyValue * 100}%, #e5e7eb 100%)`
            }}
          />
          <div className="flex justify-between text-xs text-gray-500">
            <span>0% (Ê®ôÊ∫ñ)</span>
            <span>50%</span>
            <span>100% (ÊúÄÂ§ß)</span>
          </div>
          <div className="flex items-center justify-between text-xs">
            <span className={useManualAdjustment ? 'text-green-600' : 'text-gray-500'}>
              {useManualAdjustment ? '‚úÖ ÊâãÂãïË™øÊï¥ÊúâÂäπ' : '‚è∏Ô∏è BMIËá™ÂãïË®àÁÆó‰∏≠'}
            </span>
            <button
              onClick={() => setManualBellyValue(0)}
              className="px-2 py-1 bg-gray-200 hover:bg-gray-300 rounded text-xs"
            >
              „É™„Çª„ÉÉ„Éà
            </button>
          </div>
          
          {/* „É™„Ç¢„É´„Çø„Ç§„É†ÂÄ§Ë°®Á§∫ */}
          <div className="grid grid-cols-3 gap-2 text-xs">
            <div className="bg-blue-50 p-2 rounded text-center">
              <div className="font-semibold text-blue-600">BMI</div>
              <div>{currentBMI.toFixed(1)}</div>
            </div>
            <div className="bg-green-50 p-2 rounded text-center">
              <div className="font-semibold text-green-600">„Çπ„É©„Ç§„ÉÄ„Éº</div>
              <div>{(manualBellyValue * 100).toFixed(0)}%</div>
            </div>
            <div className="bg-purple-50 p-2 rounded text-center">
              <div className="font-semibold text-purple-600">ÈÅ©Áî®ÂÄ§</div>
              <div>{manualBellyValue > 0 ? (manualBellyValue * 100).toFixed(0) + '%' : 'BMIÈÄ£Âãï'}</div>
            </div>
          </div>
          
          {/* „Éó„É™„Çª„ÉÉ„Éà„Éú„Çø„É≥ */}
          <div className="space-y-1">
            <div className="text-xs text-gray-600 font-medium">„ÇØ„Ç§„ÉÉ„ÇØË®≠ÂÆö:</div>
            <div className="grid grid-cols-5 gap-1">
              {[
                { label: 'Ê®ôÊ∫ñ', value: 0 },
                { label: 'ËªΩÂæÆ', value: 0.2 },
                { label: 'ÊôÆÈÄö', value: 0.4 },
                { label: 'È°ïËëó', value: 0.7 },
                { label: 'ÊúÄÂ§ß', value: 1.0 }
              ].map((preset) => (
                <button
                  key={preset.label}
                  onClick={() => {
                    setManualBellyValue(preset.value);
                    handleManualBellyChange(preset.value);
                  }}
                  className={`px-2 py-1 rounded text-xs transition-colors ${
                    Math.abs(manualBellyValue - preset.value) < 0.05
                      ? 'bg-blue-500 text-white'
                      : 'bg-gray-200 hover:bg-gray-300'
                  }`}
                >
                  {preset.label}
                </button>
              ))}
            </div>
          </div>
        </div>
        
        {/* „É≠„Éº„Éá„Ç£„É≥„Ç∞Áä∂ÊÖã */}
        {isLoading && (
          <div className="bg-blue-50 border border-blue-200 rounded-lg p-3">
            <p className="text-blue-700">üîÑ VRMË™≠„ÅøËæº„Åø‰∏≠...</p>
          </div>
        )}
        
        {/* „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÁä∂ÊÖã„Éá„Éê„ÉÉ„Ç∞ÔºàÈñãÁô∫Áí∞Â¢É„ÅÆ„ÅøÔºâ */}
        {process.env.NODE_ENV === 'development' && (
          <div className="bg-gray-50 border border-gray-200 rounded-lg p-2 text-xs">
            <div className="grid grid-cols-2 gap-1">
              <span className={initRef.current ? 'text-green-600' : 'text-red-600'}>
                ÂàùÊúüÂåñ: {initRef.current ? '‚úÖ' : '‚ùå'}
              </span>
              <span className={!isCleanedUpRef.current ? 'text-green-600' : 'text-red-600'}>
                „Ç¢„ÇØ„ÉÜ„Ç£„Éñ: {!isCleanedUpRef.current ? '‚úÖ' : '‚ùå'}
              </span>
              <span className={!!sceneRef.current ? 'text-green-600' : 'text-red-600'}>
                „Ç∑„Éº„É≥: {!!sceneRef.current ? '‚úÖ' : '‚ùå'}
              </span>
              <span className={!!vrmRef.current ? 'text-green-600' : 'text-red-600'}>
                VRM: {!!vrmRef.current ? '‚úÖ' : '‚ùå'}
              </span>
            </div>
          </div>
        )}
        
        {/* „Ç®„É©„ÉºË°®Á§∫ */}
        {loadingError && (
          <div className="bg-red-50 border border-red-200 rounded-lg p-3">
            <p className="text-red-700">‚ùå {loadingError}</p>
          </div>
        )}
        
        {/* „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†± */}
        {showDebugInfo && (
          <div className="bg-blue-50 border border-blue-200 rounded-lg p-3 space-y-2">
            <h5 className="font-medium text-blue-800">„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±ÔºàÊîπËâØÁâàÔºâ</h5>
            <div className="text-sm text-blue-700 space-y-1">
              <p><strong>Ë®≠ÂÆö„Åï„Çå„Åü„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó:</strong></p>
              <ul className="list-disc pl-5 space-y-1">
                {avatarData.blendShapeNames.belly && (
                  <li>belly: "{avatarData.blendShapeNames.belly}"</li>
                )}
                {avatarData.blendShapeNames.weight && (
                  <li>weight: "{avatarData.blendShapeNames.weight}"</li>
                )}
                {avatarData.blendShapeNames.fat && (
                  <li>fat: "{avatarData.blendShapeNames.fat}"</li>
                )}
              </ul>
              
              {currentBlendShape && (
                <p><strong>ÁèæÂú®‰ΩøÁî®‰∏≠:</strong> {currentBlendShape}</p>
              )}
              
              <p><strong>Âà©Áî®ÂèØËÉΩ„Å™„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÊï∞:</strong> {availableBlendShapes.length}</p>
              
              {availableBlendShapes.length === 0 && (
                <div className="bg-yellow-50 border border-yellow-200 rounded p-2 mt-2">
                  <p className="text-yellow-800 font-semibold">‚ö†Ô∏è „Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì</p>
                  <p className="text-yellow-700 text-xs">„Çπ„Ç±„Éº„É´Â§âÂΩ¢„Å´„Çà„Çã‰ª£ÊõøÊ©üËÉΩ„Çí‰ΩøÁî®„Åó„Åæ„Åô</p>
                </div>
              )}
              
              {availableBlendShapes.length > 0 && (
                <details className="mt-2">
                  <summary className="cursor-pointer text-blue-600 hover:text-blue-800">
                    „Åô„Åπ„Å¶„ÅÆ„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó„Çí„ÉÜ„Çπ„Éà ({availableBlendShapes.length}ÂÄã)
                  </summary>
                  <div className="mt-2 max-h-40 overflow-y-auto space-y-1">
                    {availableBlendShapes.map((name, index) => (
                      <div key={index} className="flex items-center justify-between bg-gray-50 p-2 rounded text-xs">
                        <span className={name === currentBlendShape ? 'font-bold text-green-600' : 'text-gray-700'}>
                          {name}
                        </span>
                        <div className="flex space-x-1">
                          <button
                            onClick={() => testBlendShape(name, 0.5)}
                            className="px-2 py-1 bg-blue-500 text-white rounded text-xs hover:bg-blue-600"
                          >
                            „ÉÜ„Çπ„Éà
                          </button>
                          <button
                            onClick={() => testBlendShape(name, 0)}
                            className="px-2 py-1 bg-gray-400 text-white rounded text-xs hover:bg-gray-500"
                          >
                            „É™„Çª„ÉÉ„Éà
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                </details>
              )}
              
              <div className="mt-2 p-2 bg-yellow-50 border border-yellow-200 rounded">
                <p className="text-xs text-yellow-700">
                  <strong>„É°„É¢„É™„É™„Éº„ÇØÂØæÁ≠ñ:</strong> „Çø„Ç§„Éû„Éº„Å®„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÅØËá™ÂãïÁöÑ„Å´„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Åï„Çå„Åæ„Åô
                </p>
                <p className="text-xs text-yellow-700 mt-1">
                  „Éá„Éê„ÉÉ„Ç∞: window.debugMemoryLeak.getReport() „Åß„É°„É¢„É™Áä∂Ê≥Å„ÇíÁ¢∫Ë™ç
                </p>
              </div>
              
              {detailedAnalysis && (
                <div className="mt-3 p-3 bg-white rounded border">
                  <h6 className="font-semibold text-gray-800 mb-2">Ë©≥Á¥∞ÂàÜÊûêÁµêÊûú</h6>
                  <div className="text-xs text-gray-600 space-y-1">
                    <p><strong>Á∑è„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„ÉóÊï∞:</strong> {detailedAnalysis.totalBlendShapes}</p>
                    <p><strong>‰ΩìÂûãÈñ¢ÈÄ£„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó:</strong> {detailedAnalysis.bodyBlendShapes.length}ÂÄã</p>
                    <p><strong>Êé®ÂÆö„É°„É¢„É™‰ΩøÁî®Èáè:</strong> {(detailedAnalysis.totalMemoryUsage / 1024).toFixed(1)}KB</p>
                    
                    {detailedAnalysis.bodyBlendShapes.length > 0 && (
                      <div className="mt-2">
                        <p><strong>‰ΩìÂûãÈñ¢ÈÄ£„Éñ„É¨„É≥„Éâ„Ç∑„Çß„Ç§„Éó‰∏ÄË¶ß:</strong></p>
                        <ul className="list-disc pl-4 mt-1 max-h-24 overflow-y-auto">
                          {detailedAnalysis.bodyBlendShapes.map((bs: any, index: number) => (
                            <li key={index} className={bs.name === currentBlendShape ? 'font-bold text-green-600' : ''}>
                              {bs.name}
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                </div>
              )}
            </div>
          </div>
        )}
      </div>
      
      {/* 3D„Éì„É•„Éº„Ç¢„Éº */}
      <div className="relative">
        <div 
          ref={containerRef}
          className="w-full rounded-lg overflow-hidden border-2 border-gray-200"
          style={{ height: '800px', backgroundColor: '#f0f0f0' }}
        />
        
        {futureBMI.length > 0 && !useManualAdjustment && (
          <div className="absolute top-3 left-3 bg-black bg-opacity-70 text-white px-3 py-2 rounded-lg text-sm">
            {futureBMI[currentPredictionIndex] && (
              <div>
                <p className="font-semibold">
                  {futureBMI[currentPredictionIndex].period === 30 ? '1„É∂ÊúàÂæå' : 
                   futureBMI[currentPredictionIndex].period === 365 ? '1Âπ¥Âæå' :
                   futureBMI[currentPredictionIndex].period === 1095 ? '3Âπ¥Âæå' :
                   futureBMI[currentPredictionIndex].period === 1825 ? '5Âπ¥Âæå' :
                   futureBMI[currentPredictionIndex].period === 3650 ? '10Âπ¥Âæå' : 
                   `${futureBMI[currentPredictionIndex].period}Êó•Âæå`}
                </p>
                <p className="text-yellow-300">BMI: {futureBMI[currentPredictionIndex].bmi.toFixed(1)}</p>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}